---
title: "4_PLSC_grad_GSR_combat"
author: "Ju-Chi.Yu"
date: "11/2/2022"
output: html_document
---

<style type="text/css">
.main-container {
max-width: 1800px;
margin-left: auto;
margin-right: auto;
}
</style>

Grabbing SPINS gradients

```{r, echo = FALSE}
library(tidyverse)
library(ggseg)
library(ggsegGlasser)
library(broom)
library(TExPosition)
library(PTCA4CATA)
library(plotly)
library(colorspace)
library(tableone)
library("RColorBrewer")
```

## Read in the SPINS big table


```{r, echo = FALSE, warning= FALSE, message='hide'}

spins_grads <- read_csv("../data/spins_gsr_RS_gradients.csv")

spins_grads_num <- data.frame(spins_grads[,c(2:5,7)])
spins_grads_num_full <- data.frame(spins_grads[,c(2:7)])
spins_grads_wide <- reshape(spins_grads_num, idvar = "Subject", timevar = "ROI", direction = "wide")
```

## read subject data

```{r, echo = FALSE, warning= FALSE, message='hide'}
load("../data/spins_RS_2mm_GSR_GlasserTian_combated_imputed.RData")
rm(rs_combat_cor_r, rs_combat_data_r, rs_combat_data_z)

lol_spins_behav <- spins_behav_impt
names(lol_spins_behav)
lol_spins_behav$subject <- sub("SPN01_", "sub-", lol_spins_behav$record_id) %>% sub("_", "", .)

## add motion data from the original behavioral set
lol_original <- 
  read_csv('../data/spins_lolivers_subject_info_for_grads_2022-05-30.csv') %>%
  filter(exclude_MRI==FALSE, 
         exclude_meanFD==FALSE, 
         exclude_earlyTerm==FALSE) %>% as.data.frame
lol_original$subject <- sub("SPN01_", "sub-", lol_original$record_id) %>% sub("_", "", .)
rownames(lol_original) <- lol_original$subject
## extract by matching the subject of lol_spins_behav
lol_spins_behav$fd_mean_rest <- lol_original[lol_spins_behav$subject,"fd_mean_rest"]

## design matrix for subjects
spins_dx <- lol_spins_behav %>%
  select(subject,scanner,diagnostic_group,demo_sex,demo_age_study_entry)
spins_dx_org <- spins_dx[,-1] %>% data.frame

## numeric data
spins_behav_num <- lol_spins_behav %>% 
  select(scog_rmet_total, scog_er40_total, #scog_mean_ea, 
         scog_tasit1_total,
         scog_tasit2_parsar, scog_tasit2_simpsar, scog_tasit2_sinc,
         scog_tasit3_lie, scog_tasit3_sar, np_domain_tscore_att_vigilance,
         np_domain_tscore_process_speed, np_domain_tscore_work_mem,
         np_domain_tscore_verbal_learning, np_domain_tscore_visual_learning,
         np_domain_tscore_reasoning_ps, 
         fd_mean_rest
         #bsfs_sec2_total, bsfs_sec3_total, bsfs_sec3_total, bsfs_sec4_total, bsfs_sec5_total, bsfs_sec6_total,
  ) %>% data.frame
# colnames(spins_behav_num)
rownames(spins_behav_num) <- lol_spins_behav$subject

## participants' variables of which the effects should be regressed out

var2regout <- lol_spins_behav %>%
  select(demo_sex, demo_age_study_entry, `fd_mean_rest`, scanner) %>% data.frame
rownames(var2regout) <- lol_spins_behav$record_id
var2regout$demo_sex_num <- as.numeric(as.factor(var2regout$demo_sex))-1
var2regout_num <- var2regout[,-1]
```

## Check subject overlap

```{r, warning= FALSE, message='hide'}
grad.sub <- spins_grads_wide$Subject[order(spins_grads_wide$Subject)]
behav.sub <- lol_spins_behav$record_id[order(lol_spins_behav$record_id)]

# behav.sub[behav.sub %in% grad.sub == FALSE]
# grad.sub[grad.sub %in% behav.sub == FALSE]

# complete.cases(spins_grads_wide)
# complete.cases(lol_spins_behav)
kept.sub <- lol_spins_behav$record_id[complete.cases(lol_spins_behav)==TRUE] # 420

## grab the matching data

behav.dat <- lol_spins_behav[kept.sub,c(6:19)]

spins_grads_wide_org <- spins_grads_wide[,-1]
rownames(spins_grads_wide_org) <- spins_grads_wide$Subject
grad.dat <- spins_grads_wide_org[kept.sub,]

## variables to regress out
regout.dat <- var2regout_num[kept.sub,]


```

## Demographics

```{r, warning= FALSE, message='hide'}

behav_all <- lol_spins_behav[kept.sub,]

table_one <- CreateTableOne(vars = colnames(behav_all)[4:19], strata="diagnostic_group",data=behav_all)

lol_demo <- 
  read_csv('../data/spins_lolivers_subject_info_for_grads_2022-04-21(withcomposite).csv') %>%
  filter(exclude_MRI==FALSE, 
         exclude_meanFD==FALSE, 
         exclude_earlyTerm==FALSE) %>% as.data.frame
lol_demo$subject <- sub("SPN01_", "sub-", lol_demo$record_id) %>% sub("_", "", .)
rownames(lol_demo) <- lol_demo$record_id
lol_demo_match <- lol_demo[kept.sub,]

spins_demo <- lol_demo_match %>% 
  select(demo_sex, demo_age_study_entry, diagnostic_group, scog_rmet_total, scog_er40_total, #scog_mean_ea,
         scog_tasit1_total,
         scog_tasit2_total, scog_tasit3_total,np_composite_tscore, np_domain_tscore_att_vigilance,
         np_domain_tscore_process_speed, np_domain_tscore_work_mem,
         np_domain_tscore_verbal_learning, np_domain_tscore_visual_learning,
         np_domain_tscore_reasoning_ps, 
         #bsfs_sec2_total, bsfs_sec3_total, bsfs_sec3_total, bsfs_sec4_total, bsfs_sec5_total, bsfs_sec6_total,
         #fd_mean_rest
  ) %>% data.frame
colnames(spins_demo)
rownames(spins_demo) <- lol_demo_match$subject

spins_demo %>%
  group_by(diagnostic_group) %>%
  summarise_if(is.numeric, mean, na.rm = TRUE) %>% t
spins_demo %>%
  group_by(diagnostic_group) %>%
  summarize_if(is.numeric, sd, na.rm = TRUE) %>% t

cbind(table(spins_demo$diagnostic_group, spins_demo$demo_sex), table(spins_demo$diagnostic_group))
```


## Regress out the effects

```{r, warning= FALSE, message='hide'}
table(regout.dat$demo_sex_num)

behav.reg <- apply(behav.dat, 2, function(x) lm(x~regout.dat$demo_sex + regout.dat$demo_age_study_entry + regout.dat$fd_mean_rest)$residual)

grad.reg <- apply(grad.dat, 2, function(x) lm(x~regout.dat$demo_sex + regout.dat$demo_age_study_entry + regout.dat$fd_mean_rest)$residual)

grad.reg2plot <- apply(grad.dat, 2, function(x){
  model <- lm(x~regout.dat$demo_sex + regout.dat$demo_age_study_entry + regout.dat$fd_mean_rest)
  return(model$residual + model$coefficient[1])
} )
```

## grab some network colours

```{r, warning= FALSE, message='hide'}
networks <- read_delim("../networks.txt", 
                       "\t", escape_double = FALSE, trim_ws = TRUE) %>%
  select(NETWORK, NETWORKKEY, RED, GREEN, BLUE, ALPHA) %>%
  distinct() %>%
  add_row(NETWORK = "Subcortical", NETWORKKEY = 13, RED = 0, GREEN=0, BLUE=0, ALPHA=255) %>%
  mutate(hex = rgb(RED, GREEN, BLUE, maxColorValue = 255)) %>%
  arrange(NETWORKKEY)

networks$hex <- darken(networks$hex, 0.2)

# oi <- networks$hex
# swatchplot(
#   "-40%" = lighten(oi, 0.4),
#   "-20%" = lighten(oi, 0.2),
#   "  0%" = oi,
#   " 20%" =  darken(oi, 0.2),
#   " 25%" =  darken(oi, 0.25),
#   " 30%" =  darken(oi, 0.3),
#   " 35%" =  darken(oi, 0.35),
#   off = c(0, 0)
# )

# networks
```

## get row and column designs

```{r}
## match ROIs to networks
ROI.network.match <- cbind(spins_grads$ROI, spins_grads$Network) %>% unique
ROI.idx <- ROI.network.match[,2]
names(ROI.idx) <- ROI.network.match[,1]
### match networks with colors
net.col.idx <- networks$hex
names(net.col.idx) <- networks$NETWORK

## design matrix for subjects
sub.dx <- spins_dx_org[kept.sub,]

diagnostic.dx <- sub.dx$diagnostic_group %>% as.matrix
diagnostic.dx <- recode(diagnostic.dx, !!!c("case" = "SSD"))
diagnostic.col.idx <- c("SSD" = "darkorchid3",
                        "control" = "gray50")
diagnostic.col <- list()
diagnostic.col$oc <- recode(diagnostic.dx, !!!diagnostic.col.idx) %>% as.matrix()
diagnostic.col$gc <- diagnostic.col.idx %>% as.matrix

## design matrix for columns - behavioral 
behav.dx <- matrix(nrow = ncol(behav.dat), ncol = 1, dimnames = list(colnames(behav.dat), "type")) %>% as.data.frame

behav.col <- c("scog" = "#D97614",#"#F28E2B",
               "np" = "#3F7538",#"#59A14F",
               "bsfs" = "#D37295")

behav.dx$type <- sub("(^[^_]+).*", "\\1", colnames(behav.dat))
behav.dx$type.col <- recode(behav.dx$type, !!!behav.col)

## design matrix for columns - gradient
grad.dx <- matrix(nrow = ncol(grad.dat), ncol = 4, dimnames = list(colnames(grad.dat), c("gradient", "ROI", "network", "network.col"))) %>% as.data.frame

grad.dx$gradient <- sub("(^[^.]+).*", "\\1", colnames(grad.dat))
grad.dx$ROI <- sub("^[^.]+.(*)", "\\1", colnames(grad.dat))
grad.dx$network <- recode(grad.dx$ROI, !!!ROI.idx)
grad.dx$network.col <- recode(grad.dx$network, !!!net.col.idx)

## get different alpha for gradients
grad.col.idx <- c("grad1" = "grey30",
                  "grad2" = "grey60",
                  "grad3" = "grey90")
grad.dx$gradient.col <- recode(grad.dx$gradient, !!!grad.col.idx)

## for heatmap
col.heat <- colorRampPalette(c("red", "white", "blue"))(256)
```

## Run PLS-C

```{r, warning= FALSE, message='hide'}
pls.res <- tepPLS(behav.reg, grad.reg, DESIGN = sub.dx$diagnostic_group, make_design_nominal = TRUE, graphs = FALSE)

pls.boot <- data4PCCAR::Boot4PLSC(behav.reg, grad.reg, scale1 = "SS1", scale2 = "SS1", nIter = 1000, nf2keep = 5, eig = TRUE)

pls.boot$bootRatiosSignificant.j[abs(pls.boot$bootRatios.j) < 2.88] <- FALSE
pls.boot$bootRatiosSignificant.i[abs(pls.boot$bootRatios.i) < 2.88] <- FALSE

pls.inf <- data4PCCAR::perm4PLSC(behav.reg, grad.reg, scale1 = "SS1", scale2 = "SS1", nIter = 1000)
# ## swith direction for dimension 3
pls.res$TExPosition.Data$fi[,1] <- pls.res$TExPosition.Data$fi[,1]*-1
pls.res$TExPosition.Data$fj[,1] <- pls.res$TExPosition.Data$fj[,1]*-1
pls.res$TExPosition.Data$pdq$p[,1] <- pls.res$TExPosition.Data$pdq$p[,1]*-1
pls.res$TExPosition.Data$pdq$q[,1] <- pls.res$TExPosition.Data$pdq$q[,1]*-1
pls.res$TExPosition.Data$lx[,1] <- pls.res$TExPosition.Data$lx[,1]*-1
pls.res$TExPosition.Data$ly[,1] <- pls.res$TExPosition.Data$ly[,1]*-1

## Scree plot
PlotScree(pls.res$TExPosition.Data$eigs, 
          p.ev = pls.inf$pEigenvalues)

## Print singular values
pls.res$TExPosition.Data$pdq$Dv
## Print eigenvalues
pls.res$TExPosition.Data$eigs
pls.res$TExPosition.Data$t
## Compare the inertia to the largest possible inertia
sum(cor(behav.dat, grad.dat)^2)
sum(cor(behav.dat, grad.dat)^2)/(ncol(behav.dat)*ncol(grad.dat))
```
Here, we show that the effect that PLSC decomposes is pretty small to begin with. The effect size of the correlation between the two tables is 92.40 which accounts for 0.0065 of the largest possible effect. 

## Results {.tabset}

```{r, include = FALSE}
lxly.out <- list()

for (check.dim in 1:5){
  
  lxly <- cbind(pls.res$TExPosition.Data$lx[,check.dim], pls.res$TExPosition.Data$ly[,check.dim])
  colnames(lxly) <- c(paste0("Dim", check.dim, c(".Behavioural", ".gradient")))
  
  lxly.boot <- Boot4Mean(lxly, diagnostic.dx, niter = 1000)
  colnames(lxly.boot$GroupMeans) <- colnames(lxly.boot$BootCube) <- c(paste0("Dim", check.dim, c(".Behavioural", ".gradient")))
  
  ## plot latent variables
  lxly.all <- createFactorMap(lxly,
                              title = paste0("Latent variables"),
                              col.background = NULL,
                              col.axes = "gray60",
                              alpha.axes = 0.5,
                              col.points = diagnostic.col$oc,
                              alpha.points = 0.5)
  
  lxly.avg <- createFactorMap(lxly.boot$GroupMeans,
                              col.points = diagnostic.col$gc[rownames(lxly.boot$GroupMeans),],
                              col.labels =  diagnostic.col$gc[rownames(lxly.boot$GroupMeans),], 
                              pch = 17, alpha.points = 0.5, text.cex = 6)
  
  lxly.CI <- MakeCIEllipses(lxly.boot$BootCube,
                            col =  diagnostic.col$gc[rownames(lxly.boot$BootCube),],
                            names.of.factors = c(paste0("Dim", check.dim, c(".Behavioural", ".gradient"))), alpha.ellipse = 0.1, line.size = 1.5)
  
  lxly.out[[check.dim]] <- lxly.all$zeMap_background + lxly.all$zeMap_dots + lxly.CI + lxly.avg$zeMap_dots + lxly.avg$zeMap_text + coord_cartesian()
  
}

q.grad1 <- pls.res$TExPosition.Data$fj[which(grad.dx$gradient == "grad1"),]
q.sig.grad1 <- pls.boot$bootRatiosSignificant.j[which(grad.dx$gradient == "grad1"),]
col.grad1 <- grad.dx$network.col[which(grad.dx$gradient == "grad1")]
dx.grad1 <- grad.dx$network[which(grad.dx$gradient == "grad1")]

q.grad2 <- pls.res$TExPosition.Data$fj[which(grad.dx$gradient == "grad2"),]
q.sig.grad2 <- pls.boot$bootRatiosSignificant.j[which(grad.dx$gradient == "grad2"),]
col.grad2 <- grad.dx$network.col[which(grad.dx$gradient == "grad2")]
dx.grad2 <- grad.dx$network[which(grad.dx$gradient == "grad2")]

q.grad3 <- pls.res$TExPosition.Data$fj[which(grad.dx$gradient == "grad3"),]
q.sig.grad3 <- pls.boot$bootRatiosSignificant.j[which(grad.dx$gradient == "grad3"),]
col.grad3 <- grad.dx$network.col[which(grad.dx$gradient == "grad3")]
dx.grad3 <- grad.dx$network[which(grad.dx$gradient == "grad3")]

```

```{r, include = FALSE}
# ## plots for presentations
# check.dim = 5
# 
# lxly <- cbind(pls.res$TExPosition.Data$lx[,check.dim], pls.res$TExPosition.Data$ly[,check.dim])
#   colnames(lxly) <- c(paste0("Dim", check.dim, c(".Behavioural", ".gradient")))
#   
#   lxly.boot <- Boot4Mean(lxly, diagnostic.dx, niter = 1000)
#   colnames(lxly.boot$GroupMeans) <- colnames(lxly.boot$BootCube) <- c(paste0("Dim", check.dim, c(".Behavioural", ".gradient")))
#   
# lxly.all.dots <- createFactorMap(lxly,
#                               title = paste0("Dimension ", check.dim),
#                               col.background = NULL,
#                               col.axes = "gray60",
#                               alpha.axes = 0.5,
#                               col.points = diagnostic.col$oc,
#                               alpha.points = 0.5)
# 
# lxly.all <- createFactorMap(lxly,
#                               title = paste0("Dimension ", check.dim),
#                               col.background = NULL,
#                               col.axes = "gray60",
#                               alpha.axes = 0.5,
#                               col.points = diagnostic.col$oc,
#                               alpha.points = 0.1)
# 
# lxly.avg <- createFactorMap(lxly.boot$GroupMeans,
#                               col.points = diagnostic.col$gc[rownames(lxly.boot$GroupMeans),],
#                               col.labels =  diagnostic.col$gc[rownames(lxly.boot$GroupMeans),], 
#                               pch = 17, alpha.points = 0.8, text.cex = 6)
#   
# lxly.CI <- MakeCIEllipses(lxly.boot$BootCube,
#                             col =  diagnostic.col$gc[rownames(lxly.boot$BootCube),],
#                             names.of.factors = c(paste0("Dim", check.dim, c(".Behavioural", ".gradient"))), alpha.ellipse = 0.1, line.size = 1.5)
# 
# lxly.all$zeMap_background + lxly.all.dots$zeMap_dots + coord_cartesian() +
#   xlab("Behavioural scores") + ylab("Brain scores") + 
#   theme(axis.text = element_text(size = 12), axis.title = element_text(size = 14))
# 
# lxly.all$zeMap_background + lxly.all$zeMap_dots + lxly.CI + lxly.avg$zeMap_dots + lxly.avg$zeMap_text + coord_cartesian() +
#   xlab("Behavioural scores") + ylab("Brain scores") + 
#   theme(axis.text = element_text(size = 12), axis.title = element_text(size = 14))
# 
# ## loadings
# fi2plot <- pls.res$TExPosition.Data$fi
# rownames(fi2plot) <- c("RMET", "ER40", "TASIT 1", "TASIT 2.sincere", "TASIT 2.simple sarcasm", "TASIT 2.paradoxical sarcasm", "TASIT 3.lies", "TASIT 3.sarcasm", "Processing speed", "Attention/Vigilance", "Working memory", "Verbal learning", "Visual learning", "Reasoning and Problem solving")
# PrettyBarPlot2(fi2plot[,check.dim],
#                threshold = 0, 
#                color4bar = ifelse(pls.boot$bootRatiosSignificant.i[,check.dim] == TRUE, behav.dx$type.col, "grey90"),
#                font.size = 4,
#                horizontal = TRUE, main = "Loadings - behavioural") + theme(axis.text.x.bottom = element_text(color = ifelse(pls.boot$bootRatiosSignificant.i[,1] == TRUE, behav.dx$type.col, "grey90")))

```


### Dimension 1

```{r,include = FALSE}

col4grad1 <- col.grad1[order(dx.grad1)]
bar.grad1 <- PrettyBarPlot2(q.grad1[order(dx.grad1),1],
                            threshold = 0, 
                            color4bar = ifelse(q.sig.grad1[,1] == TRUE, col4grad1, "grey90"), 
                            font.size = 0, main = "Scores - gradient 1")

col4grad2 <- col.grad2[order(dx.grad2)]
bar.grad2 <- PrettyBarPlot2(q.grad2[order(dx.grad2),1],
                            threshold = 0, 
                            color4bar = ifelse(q.sig.grad2[,1] == TRUE, col4grad2, "grey90"), 
                            font.size = 0, main = "Scores - gradient 2")

col4grad3 <- col.grad3[order(dx.grad3)]
bar.grad3 <- PrettyBarPlot2(q.grad3[order(dx.grad3),1],
                            threshold = 0, 
                            color4bar = ifelse(q.sig.grad3[,1] == TRUE, col4grad3, "grey90"), 
                            font.size = 0, main = "Scores - gradient 3")

```

```{r, fig.show = 'hold', out.width = '50%'}
lxly.out[[1]]

lx1.ssd <- pls.res$TExPosition.Data$lx[which(sub.dx$diagnostic_group == "case"), 1]
lx1.hc <- pls.res$TExPosition.Data$lx[which(sub.dx$diagnostic_group == "control"), 1]

gridExtra::grid.arrange(bar.grad1, bar.grad2, bar.grad3, ncol = 1)

PrettyBarPlot2(pls.res$TExPosition.Data$fi[,1],
               threshold = 0, 
               color4bar = ifelse(pls.boot$bootRatiosSignificant.i[,1] == TRUE, behav.dx$type.col, "grey90"),
               horizontal = FALSE, main = "Scores - behavioural")

cor.heat <- pls.res$TExPosition.Data$X %>% heatmap(col = col.heat)

## control
grad.dat.ctrl <- grad.dat[sub.dx$diagnostic_group == "control",]
behav.dat.ctrl <- behav.dat[sub.dx$diagnostic_group == "control",]
corX.ctrl <- cor(as.matrix(behav.dat.ctrl),as.matrix(grad.dat.ctrl))
heatmap(corX.ctrl[cor.heat$rowInd, cor.heat$colInd], col = col.heat, Rowv = NA, Colv = NA)

## case
grad.dat.case <- grad.dat[sub.dx$diagnostic_group == "case",]
behav.dat.case <- behav.dat[sub.dx$diagnostic_group == "case",]
corX.case <- cor(as.matrix(behav.dat.case),as.matrix(grad.dat.case))
heatmap(corX.case[cor.heat$rowInd, cor.heat$colInd], col = col.heat, Rowv = NA, Colv = NA)

```

#### Bootstrap confidence intervals on the first LV

```{r, echo = FALSE}
iter = 1000

CV <- function(x) sd(x)/abs(mean(x))
CV.hc <- matrix(nrow = iter, ncol = 1)
CV.ssd <- matrix(nrow = iter, ncol = 1)

for (i in 1:iter){
  boot.sample.hc <- sample(lx1.hc, length(lx1.hc), replace = TRUE)
  CV.hc[i,] <- CV(boot.sample.hc)
  
  boot.sample.ssd <- sample(lx1.ssd, length(lx1.ssd), replace = TRUE)
  CV.ssd[i,] <- CV(boot.sample.ssd)
  }

# mean(CV.hc)
# CV.hc[order(CV.hc)[25],]; CV.hc[order(CV.hc)[975],]
# 
# mean(CV.ssd)
# CV.ssd[order(CV.ssd)[25],]; CV.hc[order(CV.ssd)[975],]
```

$$CV_{control} = $$ `r round(mean(CV.hc),2)` \n 95\% bootstrap CI: [`r round(CV.hc[order(CV.hc)[25],], 2)`, `r round(CV.hc[order(CV.hc)[975],], 2)`]

$$CV_{SSD} = $$ `r round(mean(CV.ssd),2)` \n 95\% bootstrap CI: [`r round(CV.ssd[order(CV.ssd)[25],], 2)`, `r round(CV.ssd[order(CV.ssd)[975],], 2)`]

### Dimension 2

```{r, include = FALSE}
bar.grad1 <- PrettyBarPlot2(q.grad1[order(dx.grad1),2],
                            threshold = 0, 
                            color4bar = ifelse(q.sig.grad1[,2] == TRUE, col4grad1, "grey90"), 
                            font.size = 0, main = "Scores - gradient 1")

bar.grad2 <- PrettyBarPlot2(q.grad2[order(dx.grad2),2],
                            threshold = 0, 
                            color4bar = ifelse(q.sig.grad2[,2] == TRUE, col4grad2, "grey90"), 
                            font.size = 0, main = "Scores - gradient 2")

bar.grad3 <- PrettyBarPlot2(q.grad3[order(dx.grad3),2],
                            threshold = 0, 
                            color4bar = ifelse(q.sig.grad3[,2] == TRUE, col4grad3, "grey90"), 
                            font.size = 0, main = "Scores - gradient 3")

```


```{r, fig.show = 'hold', out.width = '50%'}
lxly.out[[2]]

gridExtra::grid.arrange(bar.grad1, bar.grad2, bar.grad3, ncol = 1)

PrettyBarPlot2(pls.res$TExPosition.Data$fi[,2],
               threshold = 0, color4bar = ifelse(pls.boot$bootRatiosSignificant.i[,2] == TRUE, behav.dx$type.col, "grey90"), 
               horizontal = FALSE, main = "Scores - behavioural")

dim1.est <- pls.res$TExPosition.Data$pdq$Dv[1]*as.matrix(pls.res$TExPosition.Data$pdq$p[,1], ncol = 1) %*% t(as.matrix(pls.res$TExPosition.Data$pdq$q[,1], ncol = 1))


cor.heat.res1 <- (pls.res$TExPosition.Data$X - dim1.est) %>% heatmap(col = col.heat)

```

### Dimension 3

```{r, include = FALSE}

bar.grad1 <- PrettyBarPlot2(q.grad1[order(dx.grad1),3],
                            threshold = 0, 
                            color4bar = ifelse(q.sig.grad1[,3] == TRUE, col4grad1, "grey90"),
                            font.size = 0, main = "Scores - gradient 1")

bar.grad2 <- PrettyBarPlot2(q.grad2[order(dx.grad2),3],
                            threshold = 0, 
                            color4bar = ifelse(q.sig.grad1[,3] == TRUE, col4grad1, "grey90"), 
                            font.size = 0, main = "Scores - gradient 2")

bar.grad3 <- PrettyBarPlot2(q.grad3[order(dx.grad3),3],
                            threshold = 0, 
                            color4bar = ifelse(q.sig.grad1[,3] == TRUE, col4grad1, "grey90"), 
                            font.size = 0, main = "Scores - gradient 3")

```


```{r, fig.show = 'hold', out.width = '50%'}
lxly.out[[3]]

gridExtra::grid.arrange(bar.grad1, bar.grad2, bar.grad3, ncol = 1)

PrettyBarPlot2(pls.res$TExPosition.Data$fi[,3],
               threshold = 0, color4bar = ifelse(pls.boot$bootRatiosSignificant.i[,3] == TRUE, behav.dx$type.col, "grey90"),
               horizontal = FALSE, main = "Scores - behavioural")

dim2.est <- (as.matrix(pls.res$TExPosition.Data$pdq$p[,1:2]) %*% pls.res$TExPosition.Data$pdq$Dd[1:2,1:2] %*% t(as.matrix(pls.res$TExPosition.Data$pdq$q[,1:2])))


cor.heat.res2 <- heatmap(pls.res$TExPosition.Data$X - dim2.est, col = col.heat)

```

### Dimension 4

```{r,include = FALSE}

col4grad1 <- col.grad1[order(dx.grad1)]
bar.grad1 <- PrettyBarPlot2(q.grad1[order(dx.grad1),4],
                            threshold = 0, 
                            color4bar = ifelse(q.sig.grad1[,4] == TRUE, col4grad1, "grey90"), 
                            font.size = 0, main = "Scores - gradient 1")

col4grad2 <- col.grad2[order(dx.grad2)]
bar.grad2 <- PrettyBarPlot2(q.grad2[order(dx.grad2),4],
                            threshold = 0, 
                            color4bar = ifelse(q.sig.grad2[,4] == TRUE, col4grad2, "grey90"), 
                            font.size = 0, main = "Scores - gradient 2")

col4grad3 <- col.grad3[order(dx.grad3)]
bar.grad3 <- PrettyBarPlot2(q.grad3[order(dx.grad3),4],
                            threshold = 0, 
                            color4bar = ifelse(q.sig.grad3[,4] == TRUE, col4grad3, "grey90"), 
                            font.size = 0, main = "Scores - gradient 3")

```


```{r, fig.show = 'hold', out.width = '50%'}
lxly.out[[4]]

gridExtra::grid.arrange(bar.grad1, bar.grad2, bar.grad3, ncol = 1)

PrettyBarPlot2(pls.res$TExPosition.Data$fi[,4],
               threshold = 0, 
               color4bar = ifelse(pls.boot$bootRatiosSignificant.i[,4] == TRUE, behav.dx$type.col, "grey90"),
               horizontal = FALSE, main = "Scores - behavioural")


dim3.est <- (as.matrix(pls.res$TExPosition.Data$pdq$p[,1:3]) %*% pls.res$TExPosition.Data$pdq$Dd[1:3,1:3] %*% t(as.matrix(pls.res$TExPosition.Data$pdq$q[,1:3])))


cor.heat.res3 <- heatmap(pls.res$TExPosition.Data$X - dim3.est, col = col.heat)

```

## Back into the brain {.tabset} 

```{r, include = FALSE}
## reorganize data frame
# factor scores
full.pq <- data.frame(grad.dx[,1:4], pls.res$TExPosition.Data$fj[,1:4], colMeans(grad.dat))
colnames(full.pq)[5:9] <- c(paste0("fj", c(1:4)), "raw")

# filtered by significance
full.pq.sig <- full.pq[,5:8]
full.pq.sig[pls.boot$bootRatiosSignificant.j[,1:4] == FALSE] <- 0
full.pq[,10:13] <- full.pq.sig
colnames(full.pq)[10:13] <- c(paste0("fj.sig", c(1:4)))

# contributions
full.cj <- data.frame(grad.dx[,1:4],
                      pls.res$TExPosition.Data$cj[,1:4],
                      colMeans(grad.dat))
colnames(full.cj)[5:9] <- c(paste0("cj", c(1:4)), "raw")
full.cj.sig <- full.cj[,5:8]
full.cj.sig[pls.boot$bootRatiosSignificant.j[,1:4] == FALSE] <- 0
full.cj[,10:13] <- full.cj.sig
colnames(full.cj)[10:13] <- c(paste0("cjsig", c(1:4)))

# filtered by importance (1/#J)
full.cj.imp <- full.cj[,5:8]
full.cj.imp[full.cj[,5:8] < 1/nrow(full.cj)] <- 0
full.cj[,14:17] <- full.cj.imp
colnames(full.cj)[14:17] <- c(paste0("cjimp", c(1:4)))

## sign
full.cj[,c("dir.1", "dir.2", "dir.3", "dir.4")] <- sign(pls.res$TExPosition.Data$fj[,1:4])

## full positive contributions
full.cj[,c("cj1_x_mean", "cj2_x_mean", "cj3_x_mean", "cj4_x_mean")] <- full.cj[,c("cj1", "cj2", "cj3", "cj4")]*full.cj$raw

full.cj[,c("cj1_x_mean.pos", "cj2_x_mean.pos", "cj3_x_mean.pos", "cj4_x_mean.pos")] <- full.cj[,c("cj1_x_mean.neg", "cj2_x_mean.neg", "cj3_x_mean.neg", "cj4_x_mean.neg")] <- full.cj[,c("cj1_x_mean", "cj2_x_mean", "cj3_x_mean", "cj4_x_mean")] 

## filtered by significance (bootstrap of fj)
full.cj[,c("cjsig1_x_mean", "cjsig2_x_mean", "cjsig3_x_mean", "cjsig4_x_mean")] <- full.cj[,c("cjsig1", "cjsig2", "cjsig3", "cjsig4")]*full.cj$raw

## filtered by importance (q^2)
full.cj[,c("cjimp1_x_mean", "cjimp2_x_mean", "cjimp3_x_mean", "cjimp4_x_mean")] <- full.cj[,c("cjimp1", "cjimp2", "cjimp3", "cjimp4")]*full.cj$raw

## separate by sign

full.cj <- full.cj %>% mutate(
                   cjimp1.pos = if_else(dir.1 > 0,cjimp1,0),
                   cjimp2.pos = if_else(dir.2 > 0,cjimp2,0),
                   cjsig1.pos = if_else(dir.1 > 0,cjsig1,0),
                   cjsig2.pos = if_else(dir.2 > 0,cjsig2,0),
                   cj1_x_mean.pos = if_else(dir.1 > 0,cj1_x_mean,0),
                   cj2_x_mean.pos = if_else(dir.2 > 0,cj2_x_mean,0),
                   cj3_x_mean.pos = if_else(dir.3 > 0,cj3_x_mean,0),
                   cj4_x_mean.pos = if_else(dir.4 > 0,cj4_x_mean,0),
                   cjsig1_x_mean.pos = if_else(dir.1 > 0,cjsig1_x_mean,0),
                   cjsig2_x_mean.pos = if_else(dir.2 > 0,cjsig2_x_mean,0),
                   cjsig3_x_mean.pos = if_else(dir.3 > 0,cjsig3_x_mean,0),
                   cjsig4_x_mean.pos = if_else(dir.4 > 0,cjsig4_x_mean,0),
                   cjimp1_x_mean.pos = if_else(dir.1 > 0,cjimp1_x_mean,0),
                   cjimp2_x_mean.pos = if_else(dir.2 > 0,cjimp2_x_mean,0),
                   cjimp3_x_mean.pos = if_else(dir.3 > 0,cjimp3_x_mean,0),
                   cjimp4_x_mean.pos = if_else(dir.4 > 0,cjimp4_x_mean,0),
                   cjimp1.neg = if_else(dir.1 < 0,cjimp1,0),
                   cjimp2.neg = if_else(dir.2 < 0,cjimp2,0),
                   cjsig1.neg = if_else(dir.1 < 0,cjsig1,0),
                   cjsig2.neg = if_else(dir.2 < 0,cjsig2,0),
                   cj1_x_mean.neg = if_else(dir.1 < 0,cj1_x_mean,0),
                   cj2_x_mean.neg = if_else(dir.2 < 0,cj2_x_mean,0),
                   cj3_x_mean.neg = if_else(dir.3 < 0,cj3_x_mean,0),
                   cj4_x_mean.neg = if_else(dir.4 < 0,cj4_x_mean,0),
                   cjsig1_x_mean.neg = if_else(dir.1 < 0,cjsig1_x_mean,0),
                   cjsig2_x_mean.neg = if_else(dir.2 < 0,cjsig2_x_mean,0),
                   cjsig3_x_mean.neg = if_else(dir.3 < 0,cjsig3_x_mean,0),
                   cjsig4_x_mean.neg = if_else(dir.4 < 0,cjsig4_x_mean,0),
                   cjimp1_x_mean.neg = if_else(dir.1 < 0,cjimp1_x_mean,0),
                   cjimp2_x_mean.neg = if_else(dir.2 < 0,cjimp2_x_mean,0),
                   cjimp3_x_mean.neg = if_else(dir.3 < 0,cjimp3_x_mean,0),
                   cjimp4_x_mean.neg = if_else(dir.4 < 0,cjimp4_x_mean,0))

# Organize data
pq_for_plot <- full.pq %>% 
  mutate(roi = str_remove(ROI, "_ROI"),
         label = case_when(str_starts(ROI, "L") ~ str_c("lh_", roi),
                           str_starts(ROI, "R_") ~ str_c("rh_", roi)))

pqxcj_for_plot <- full.cj %>% 
  mutate(roi = str_remove(ROI, "_ROI"),
         label = case_when(str_starts(ROI, "L") ~ str_c("lh_", roi),
                           str_starts(ROI, "R_") ~ str_c("rh_", roi)))

# plot brain
gradient_raw_brain <- pq_for_plot %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = raw),
             atlas = glasser) +
  facet_wrap(~gradient, ncol = 1, labeller = labeller(gradient = 
                                                        c("grad1" = "Gradient 1",
                                                          "grad2" = "Gradient 2",
                                                          "grad3" = "Gradient 3")
  )) +
  scale_fill_distiller(name = "Scores", palette = "BrBG", limits = c(-1,1.5), values = c(0, 0.266, 0.4, 0.6, 1)) +
  ggtitle("Gradients")+
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

```

### Dimension 1

```{r, echo = FALSE, warning= FALSE, message='hide', fig.show = 'hold', out.width = '50%'}
gradient_raw_brain

pq_for_plot %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = fj.sig1),
             atlas = glasser) +
  facet_wrap(~gradient, ncol = 1, labeller = labeller(gradient = 
                                                        c("grad1" = "Gradient 1: Somatosensory vs. Frontoparietal",
                                                          "grad2" = "Gradient 2: Auditory/Motion vs. Vision",
                                                          "grad3" = "Gradient 3: Default mode vs. frontoparietal")
  )) +
  scale_fill_distiller(name = "fj", palette = "RdBu", limits = c(-1,1), values = c(0, 0.45, 0.5, 0.55, 1)) +
  ggtitle(sprintf("PLSC: Dimension 1 (%.02f%% of variance)", pls.res$TExPosition.Data$t[1])) + 
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

pq_for_plot %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = fj1),
             atlas = glasser) +
  facet_wrap(~gradient, ncol = 1, labeller = labeller(gradient = 
                                                        c("grad1" = "Gradient 1: Somatosensory vs. Frontoparietal",
                                                          "grad2" = "Gradient 2: Auditory/Motion vs. Vision",
                                                          "grad3" = "Gradient 3: Default mode vs. frontoparietal")
  )) +
  scale_fill_distiller(name = "fj.sig", palette = "RdBu", limits = c(-1,1), values = c(0, 0.45, 0.5, 0.55, 1)) +
  ggtitle(sprintf("PLSC: Dimension 1 (%.02f%% of variance)", pls.res$TExPosition.Data$t[1])) + 
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

PrettyBarPlot2(pls.res$TExPosition.Data$fi[,1],
               threshold = 0, 
               color4bar = ifelse(pls.boot$bootRatiosSignificant.i[,1] == TRUE, behav.dx$type.col, "grey90"),
               main = "Loadings - behavioural")

## positive (non-filtered)
pqxcj_for_plot %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = cj1_x_mean.pos),
             atlas = glasser) +
  facet_wrap(~gradient, ncol = 1, labeller = labeller(gradient = 
                                                        c("grad1" = "Gradient 1: Somatosensory vs. Frontoparietal",
                                                          "grad2" = "Gradient 2: Auditory/Motion vs. Vision",
                                                          "grad3" = "Gradient 3: Default mode vs. frontoparietal")
  )) +
  scale_fill_distiller(name = "Value", palette = "BrBG", limits = c(-0.007,0.007), values = c(0, 0.45, 0.5, 0.55, 1)) +
  ggtitle(sprintf("PLSC Dimension 1 (positive): %.02f%% of variance\nGradient (weighted by contribution)", pls.res$TExPosition.Data$t[1])) + 
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

## negative (non-filtered)
pqxcj_for_plot %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = cj1_x_mean.neg),
             atlas = glasser) +
  facet_wrap(~gradient, ncol = 1, labeller = labeller(gradient = 
                                                        c("grad1" = "Gradient 1: Somatosensory vs. Frontoparietal",
                                                          "grad2" = "Gradient 2: Auditory/Motion vs. Vision",
                                                          "grad3" = "Gradient 3: Default mode vs. frontoparietal")
  )) +
  scale_fill_distiller(name = "Value", palette = "BrBG", limits = c(-0.007,0.007), values = c(0, 0.45, 0.5, 0.55, 1)) +
  ggtitle(sprintf("PLSC Dimension 1 (negative): %.02f%% of variance\nGradient (weighted by contribution)", pls.res$TExPosition.Data$t[1])) + 
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

## positive (filtered by importance)
pqxcj_for_plot %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = cjimp1_x_mean.pos),
             atlas = glasser) +
  facet_wrap(~gradient, ncol = 1, labeller = labeller(gradient = 
                                                        c("grad1" = "Gradient 1: Somatosensory vs. Frontoparietal",
                                                          "grad2" = "Gradient 2: Auditory/Motion vs. Vision",
                                                          "grad3" = "Gradient 3: Default mode vs. frontoparietal")
  )) +
  scale_fill_distiller(name = "Value", palette = "BrBG", limits = c(-0.007,0.007), values = c(0, 0.45, 0.5, 0.55, 1)) +
  ggtitle(sprintf("PLSC Dimension 1 (important positive): %.02f%% of variance\nGradient (weighted by contribution)", pls.res$TExPosition.Data$t[1])) + 
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

## negative (filtered by importance)
pqxcj_for_plot %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = cjimp1_x_mean.neg),
             atlas = glasser) +
  facet_wrap(~gradient, ncol = 1, labeller = labeller(gradient = 
                                                        c("grad1" = "Gradient 1: Somatosensory vs. Frontoparietal",
                                                          "grad2" = "Gradient 2: Auditory/Motion vs. Vision",
                                                          "grad3" = "Gradient 3: Default mode vs. frontoparietal")
  )) +
  scale_fill_distiller(name = "Value", palette = "BrBG", limits = c(-0.007,0.007), values = c(0, 0.45, 0.5, 0.55, 1)) +
  ggtitle(sprintf("PLSC Dimension 1 (important negative): %.02f%% of variance\nGradient (weighted by contribution)", pls.res$TExPosition.Data$t[1])) + 
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

## positive (filtered)
pqxcj_for_plot %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = cjsig1_x_mean.pos),
             atlas = glasser) +
  facet_wrap(~gradient, ncol = 1, labeller = labeller(gradient = 
                                                        c("grad1" = "Gradient 1: Somatosensory vs. Frontoparietal",
                                                          "grad2" = "Gradient 2: Auditory/Motion vs. Vision",
                                                          "grad3" = "Gradient 3: Default mode vs. frontoparietal")
  )) +
  scale_fill_distiller(name = "Value", palette = "BrBG", limits = c(-0.007,0.007), values = c(0, 0.45, 0.5, 0.55, 1)) +
  ggtitle(sprintf("PLSC Dimension 1 (significant positive): %.02f%% of variance\nGradient (weighted by contribution)", pls.res$TExPosition.Data$t[1])) + 
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

## negative (non-filtered)
pqxcj_for_plot %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = cjsig1_x_mean.neg),
             atlas = glasser) +
  facet_wrap(~gradient, ncol = 1, labeller = labeller(gradient = 
                                                        c("grad1" = "Gradient 1: Somatosensory vs. Frontoparietal",
                                                          "grad2" = "Gradient 2: Auditory/Motion vs. Vision",
                                                          "grad3" = "Gradient 3: Default mode vs. frontoparietal")
  )) +
  scale_fill_distiller(name = "Value", palette = "BrBG", limits = c(-0.007,0.007), values = c(0, 0.45, 0.5, 0.55, 1)) +
  ggtitle(sprintf("PLSC Dimension 1 (significant negative): %.02f%% of variance\nGradient (weighted by contribution)", pls.res$TExPosition.Data$t[1])) + 
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

```

### Dimension 2

```{r, echo = FALSE, warning= FALSE, message='hide', fig.show = 'hold', out.width = '50%'}
gradient_raw_brain

pq_for_plot %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = fj.sig2),
             atlas = glasser) +
  facet_wrap(~gradient, ncol = 1) +
  scale_fill_distiller(palette = "RdBu", limits = c(-1,1), values = c(0, 0.45, 0.5, 0.55, 1)) +
  ggtitle("PLSC: Dimension 2")+ 
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

pq_for_plot %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = fj2),
             atlas = glasser) +
  facet_wrap(~gradient, ncol = 1) +
  scale_fill_distiller(palette = "RdBu", limits = c(-1,1), values = c(0, 0.45, 0.5, 0.55, 1)) +
  ggtitle("PLSC: Dimension 2")+ 
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

PrettyBarPlot2(pls.res$TExPosition.Data$fi[,2],
               threshold = 0, 
               color4bar = ifelse(pls.boot$bootRatiosSignificant.i[,2] == TRUE, behav.dx$type.col, "grey90"),
               main = "Loadings - behavioural")

## positive (non-filtered)
pqxcj_for_plot %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = cj2_x_mean.pos),
             atlas = glasser) +
  facet_wrap(~gradient, ncol = 1, labeller = labeller(gradient = 
                                                        c("grad1" = "Gradient 1: Somatosensory vs. Frontoparietal",
                                                          "grad2" = "Gradient 2: Auditory/Motion vs. Vision",
                                                          "grad3" = "Gradient 3: Default mode vs. frontoparietal")
  )) +
  scale_fill_distiller(name = "Value", palette = "BrBG", limits = c(-0.006,0.006), values = c(0, 0.45, 0.5, 0.55, 1)) +
  ggtitle(sprintf("PLSC Dimension 2 (positive): %.02f%% of variance\nGradient (weighted by contribution)", pls.res$TExPosition.Data$t[2])) + 
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

## negative (non-filtered)
pqxcj_for_plot %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = cj2_x_mean.neg),
             atlas = glasser) +
  facet_wrap(~gradient, ncol = 1, labeller = labeller(gradient = 
                                                        c("grad1" = "Gradient 1: Somatosensory vs. Frontoparietal",
                                                          "grad2" = "Gradient 2: Auditory/Motion vs. Vision",
                                                          "grad3" = "Gradient 3: Default mode vs. frontoparietal")
  )) +
  scale_fill_distiller(name = "Value", palette = "BrBG", limits = c(-0.006,0.006), values = c(0, 0.45, 0.5, 0.55, 1)) +
  ggtitle(sprintf("PLSC Dimension 2 (negative): %.02f%% of variance\nGradient (weighted by contribution)", pls.res$TExPosition.Data$t[2])) + 
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

## positive (filtered by importance)
pqxcj_for_plot %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = cjimp2_x_mean.pos),
             atlas = glasser) +
  facet_wrap(~gradient, ncol = 1, labeller = labeller(gradient = 
                                                        c("grad1" = "Gradient 1: Somatosensory vs. Frontoparietal",
                                                          "grad2" = "Gradient 2: Auditory/Motion vs. Vision",
                                                          "grad3" = "Gradient 3: Default mode vs. frontoparietal")
  )) +
  scale_fill_distiller(name = "Value", palette = "BrBG", limits = c(-0.006,0.006), values = c(0, 0.45, 0.5, 0.55, 1)) +
  ggtitle(sprintf("PLSC Dimension 2 (important positive): %.02f%% of variance\nGradient (weighted by contribution)", pls.res$TExPosition.Data$t[2])) + 
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

## negative (filtered by importance)
pqxcj_for_plot %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = cjimp2_x_mean.neg),
             atlas = glasser) +
  facet_wrap(~gradient, ncol = 1, labeller = labeller(gradient = 
                                                        c("grad1" = "Gradient 1: Somatosensory vs. Frontoparietal",
                                                          "grad2" = "Gradient 2: Auditory/Motion vs. Vision",
                                                          "grad3" = "Gradient 3: Default mode vs. frontoparietal")
  )) +
  scale_fill_distiller(name = "Value", palette = "BrBG", limits = c(-0.006,0.006), values = c(0, 0.45, 0.5, 0.55, 1)) +
  ggtitle(sprintf("PLSC Dimension 2 (importance negative): %.02f%% of variance\nGradient (weighted by contribution)", pls.res$TExPosition.Data$t[2])) + 
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

## positive (filtered)
pqxcj_for_plot %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = cjsig2_x_mean.pos),
             atlas = glasser) +
  facet_wrap(~gradient, ncol = 1, labeller = labeller(gradient = 
                                                        c("grad1" = "Gradient 1: Somatosensory vs. Frontoparietal",
                                                          "grad2" = "Gradient 2: Auditory/Motion vs. Vision",
                                                          "grad3" = "Gradient 3: Default mode vs. frontoparietal")
  )) +
  scale_fill_distiller(name = "Value", palette = "BrBG", limits = c(-0.006,0.006), values = c(0, 0.45, 0.5, 0.55, 1)) +
  ggtitle(sprintf("PLSC Dimension 2 (significant positive): %.02f%% of variance\nGradient (weighted by contribution)", pls.res$TExPosition.Data$t[2])) + 
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

## negative (non-filtered)
pqxcj_for_plot %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = cjsig2_x_mean.neg),
             atlas = glasser) +
  facet_wrap(~gradient, ncol = 1, labeller = labeller(gradient = 
                                                        c("grad1" = "Gradient 1: Somatosensory vs. Frontoparietal",
                                                          "grad2" = "Gradient 2: Auditory/Motion vs. Vision",
                                                          "grad3" = "Gradient 3: Default mode vs. frontoparietal")
  )) +
  scale_fill_distiller(name = "Value", palette = "BrBG", limits = c(-0.006,0.006), values = c(0, 0.45, 0.5, 0.55, 1)) +
  ggtitle(sprintf("PLSC Dimension 2 (significant negative): %.02f%% of variance\nGradient (weighted by contribution)", pls.res$TExPosition.Data$t[2])) + 
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")
```

### Dimension 3

```{r, echo = FALSE, warning= FALSE, message='hide', fig.show = 'hold', out.width = '50%'}
gradient_raw_brain

pq_for_plot %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = fj.sig3),
             atlas = glasser) +
  facet_wrap(~gradient, ncol = 1) +
  scale_fill_distiller(palette = "RdBu", limits = c(-1,1), values = c(0, 0.45, 0.5, 0.55, 1)) +
  ggtitle("PLSC: Dimension 3")+ 
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

pq_for_plot %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = fj3),
             atlas = glasser) +
  facet_wrap(~gradient, ncol = 1) +
  scale_fill_distiller(palette = "RdBu", limits = c(-1,1), values = c(0, 0.45, 0.5, 0.55, 1)) +
  ggtitle("PLSC: Dimension 3")+ 
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

PrettyBarPlot2(pls.res$TExPosition.Data$fi[,3],
               threshold = 0, 
               color4bar = ifelse(pls.boot$bootRatiosSignificant.i[,3] == TRUE, behav.dx$type.col, "grey90"),
               main = "Loadings - behavioural")
```

### Dimension 4

```{r, echo = FALSE, warning= FALSE, message='hide', fig.show = 'hold', out.width = '50%'}
gradient_raw_brain

pq_for_plot %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = fj.sig4),
             atlas = glasser) +
  facet_wrap(~gradient, ncol = 1) +
  scale_fill_distiller(palette = "RdBu", limits = c(-1,1), values = c(0, 0.45, 0.5, 0.55, 1)) +
  ggtitle("PLSC: Dimension 4")+ 
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

pq_for_plot %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = fj4),
             atlas = glasser) +
  facet_wrap(~gradient, ncol = 1) +
  scale_fill_distiller(palette = "RdBu", limits = c(-1,1), values = c(0, 0.45, 0.5, 0.55, 1)) +
  ggtitle("PLSC: Dimension 4")+ 
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

PrettyBarPlot2(pls.res$TExPosition.Data$fi[,4],
               threshold = 0, 
               color4bar = ifelse(pls.boot$bootRatiosSignificant.i[,4] == TRUE, behav.dx$type.col, "grey90"),
               main = "Loadings - behavioural")
```

## Group difference and fancy figures {.tabset}

```{r, include = FALSE}
grad.reg.long <- data.frame(t(grad.reg2plot), grad.dx[,1:3])
grad.reg.wide <- grad.reg.long %>% pivot_longer(cols = "SPN01_CMH_0001":"SPN01_ZHP_0171",
                                                names_to = "Subject",
                                                names_prefix = "",
                                                values_to = "value") 
grad.reg.wide4plot <- grad.reg.wide %>% pivot_wider(names_from = "gradient",
                                                    names_prefix = "",
                                                    values_from = "value",) %>% data.frame
grad.reg.wide4plot$Subject <- sub("sub.", "sub-", grad.reg.wide4plot$Subject)
names(grad.reg.wide4plot)[2] <- "Network"

## organize data - contributions
spins_cj <- list(grad1 = pqxcj_for_plot %>% filter(gradient == "grad1"),
                 grad2 = pqxcj_for_plot %>% filter(gradient == "grad2"),
                 grad3 = pqxcj_for_plot %>% filter(gradient == "grad3"))

spins_cj <- lapply(spins_cj, function(x) {
   rownames(x) <- spins_cj$grad1$ROI
   return(x)
  })

## organize data - ROI average
spins_mean <- getMeans(grad.reg.wide4plot[,4:6], grad.reg.wide4plot$ROI)
grad2plot <- spins_mean
colnames(grad2plot) <- c(paste0("Gradient ", c(1:3)))
grad4grp <- unique(grad.reg.wide4plot[,c(1,2)]) %>% data.frame
rownames(grad4grp) <- grad4grp$ROI

## organize data - network mean
net_mean <- getMeans(spins_mean, grad4grp[rownames(spins_mean), "Network"])
colnames(net_mean) <- c(paste0("Gradient ", c(1:3)))

## organize data - ROI & group average
spins_grad_everything <- merge(grad.reg.wide4plot, sub.dx, by.x = "Subject", by.y = 0)

spins_mean_bygrp<- spins_grad_everything %>% 
  group_by(ROI, Network,diagnostic_group) %>% 
  dplyr::summarize(across(starts_with("grad"), ~ mean(.x, na.rm = TRUE))) %>%
  as.data.frame %>%
  reshape(idvar = c("ROI", "Network"), timevar = "diagnostic_group", direction = "wide")

spins_sd_bygrp<- spins_grad_everything %>% 
  group_by(ROI, Network,diagnostic_group) %>% 
  dplyr::summarize(across(starts_with("grad"), ~ sd(.x, na.rm = TRUE))) %>%
  as.data.frame %>%
  reshape(idvar = c("ROI", "Network"), timevar = "diagnostic_group", direction = "wide")

grad2plot2 <- spins_mean_bygrp[,c(3:8)]
grad4grp2 <- unique(spins_mean_bygrp[,c(1:2)]) %>% as.data.frame
rownames(grad4grp2) <- grad4grp2$ROI
rownames(grad2plot2) <- grad4grp2$ROI

## organize data - network mean by groups
net_mean_bygrp <- spins_mean_bygrp %>%
  group_by(Network) %>%
  dplyr::summarize(across(starts_with("grad"), ~ mean(.x, na.rm = TRUE))) %>%
  as.data.frame
rownames(net_mean_bygrp) <- net_mean_bygrp$Network

## get colors
roi.col <- list()
roi.col$oc <- recode(grad4grp$Network, !!!net.col.idx) %>% as.matrix
rownames(roi.col$oc) <- grad4grp$ROI
roi.col$gc <- as.matrix(net.col.idx)

## data for arrows with q
grad_fjxgrad <- data.frame(pls.res$TExPosition.Data$pdq$q[,1:3]*5, grad.dx[,c("ROI", "gradient")])
colnames(grad_fjxgrad)[1:3] <- paste0("Dim", c(1:3))
grad_fj_wide <- reshape(grad_fjxgrad, idvar = "ROI", timevar = "gradient", direction = "wide") %>% as.data.frame
grad_fj_wide$Network <- grad4grp[grad_fj_wide$ROI, "Network"]
rownames(grad_fj_wide) <- grad_fj_wide$ROI

net_mean.fj <- getMeans(grad_fj_wide[,2:10], grad_fj_wide$Network)

## color of arrows
arrow.col <- darken(roi.col$gc[rownames(net_mean),], 0.4)
names(arrow.col) <- rownames(net_mean)
```

### Cohen's 

```{r, echo = FALSE, warning= FALSE, message='hide', fig.show = 'hold', out.width = '50%'}
## plot case
case_roi_results <- spins_mean_bygrp[,1:5] %>%
  pivot_longer(grad1.case:grad3.case, names_to = "gradient", values_to = "grad_value") %>%
  mutate(roi = str_remove(ROI, "_ROI"),
         label = case_when(str_starts(ROI, "L") ~ str_c("lh_", roi),
                           str_starts(ROI, "R_") ~ str_c("rh_", roi))) %>%
  filter(Network != "Subcortical") %>%
  filter(ROI != "L_10pp_ROI") %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = grad_value),
        atlas = glasser) +
  facet_wrap(~gradient, ncol = 1, labeller = labeller(gradient = 
                                                        c("grad1" = "Gradient 1: Somatosensory vs. Frontoparietal",
                                                          "grad2" = "Gradient 2: Auditory/Motion vs. Vision",
                                                          "grad3" = "Gradient 3: Default mode vs. frontoparietal")
  )) +
  scale_fill_distiller(name = "Scores", palette = "BrBG", limits = c(-1.3,1.5), values = c(0, 0.286, 0.464, 0.643, 1)) +
  ggtitle("SSD")+  
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

## Glasser atlas
net.col.idx.light <- lighten(net.col.idx)
names(net.col.idx.light) <- names(net.col.idx)

glasser_brain <- pq_for_plot %>%
  as.data.frame() %>%
   group_by(gradient) %>%
   filter(gradient == "grad1") %>%
  ggplot() +
  geom_brain(mapping = aes(fill = network),
             atlas = glasser)+
  scale_fill_manual(name = "Networks", values = net.col.idx.light) +
  ggtitle("Gradients")+
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank(),
        legend.position = "bottom") + 
  theme_brain(text.family = "Calibri") +
   guides(fill = guide_legend(ncol = 4))

glasser_brain4plot <- pq_for_plot %>%
  as.data.frame() %>%
   group_by(gradient) %>%
   filter(gradient == "grad1") %>%
  ggplot() +
  geom_brain(mapping = aes(fill = network),
             atlas = glasser,
             position = position_brain(hemi~side))+
  scale_fill_manual(name = "Networks", values = net.col.idx.light) +
  ggtitle("Gradients")+
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank(),
        legend.position = "") + 
  theme_brain(text.family = "Calibri")
 
## plot control
control_roi_results <- spins_mean_bygrp[,c(1:2, 6:8)] %>%
  pivot_longer(grad1.control:grad3.control, names_to = "gradient", values_to = "grad_value") %>%
  mutate(roi = str_remove(ROI, "_ROI"),
         label = case_when(str_starts(ROI, "L") ~ str_c("lh_", roi),
                           str_starts(ROI, "R_") ~ str_c("rh_", roi))) %>%
  filter(Network != "Subcortical") %>%
  filter(ROI != "L_10pp_ROI") %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = grad_value),
        atlas = glasser) +
  facet_wrap(~gradient, ncol = 1, labeller = labeller(gradient = 
                                                        c("grad1" = "Gradient 1: Somatosensory vs. Frontoparietal",
                                                          "grad2" = "Gradient 2: Auditory/Motion vs. Vision",
                                                          "grad3" = "Gradient 3: Default mode vs. frontoparietal")
  )) +
  scale_fill_distiller(name = "Scores", palette = "BrBG", limits = c(-1.3,1.5), values = c(0, 0.286, 0.464, 0.643, 1)) +
  ggtitle("Controls")+  
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

## compute the difference with GLM
all_roi_results <- spins_grad_everything %>%
  pivot_longer(grad1:grad3, names_to = "gradient", values_to = "grad_value") %>%
    ungroup() %>%
  group_by(Network, gradient, ROI) %>%
  do(tidy(lm(grad_value ~ diagnostic_group, data = .))) %>%
  ungroup() %>%
  group_by(term) %>%
  mutate(p_FDR = p.adjust(p.value, method = "fdr"))

## plot the F statistics
all_roi_results %>%
  filter(term == "diagnostic_groupcontrol") %>%
  mutate(roi = str_remove(ROI, "_ROI"),
         label = case_when(str_starts(ROI, "L") ~ str_c("lh_", roi),
                           str_starts(ROI, "R_") ~ str_c("rh_", roi)),
         statistic.cor = ifelse(p_FDR < 0.05, statistic, 0)) %>%
  # filter(Network != "Subcortical") %>%
  filter(ROI != "L_10pp_ROI") %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = statistic),
        atlas = glasser) +
  facet_wrap(~gradient, ncol = 1, labeller = labeller(gradient = 
                                                        c("grad1" = "Gradient 1: Somatosensory vs. Frontoparietal",
                                                          "grad2" = "Gradient 2: Auditory/Motion vs. Vision",
                                                          "grad3" = "Gradient 3: Default mode vs. frontoparietal")
  )) +
  scale_fill_distiller(name = "F value", palette = "RdBu", limits = c(-7,7), values = c(0, 0.25, 0.5, 0.75, 1)) +
  ggtitle("Gradients: Controls > SSD")+
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")


## plot the F statistics (filtered by FDR test)
all_roi_results %>%
  filter(term == "diagnostic_groupcontrol") %>%
  mutate(roi = str_remove(ROI, "_ROI"),
         label = case_when(str_starts(ROI, "L") ~ str_c("lh_", roi),
                           str_starts(ROI, "R_") ~ str_c("rh_", roi)),
         statistic.cor = ifelse(p_FDR < 0.05, statistic, 0)) %>%
  # filter(Network != "Subcortical") %>%
  filter(ROI != "L_10pp_ROI") %>%
  as.data.frame() %>%
  group_by(gradient) %>%
  ggplot() +
  geom_brain(mapping = aes(fill = statistic.cor),
        atlas = glasser) +
  facet_wrap(~gradient, ncol = 1, labeller = labeller(gradient = 
                                                        c("grad1" = "Gradient 1: Somatosensory vs. Frontoparietal",
                                                          "grad2" = "Gradient 2: Auditory/Motion vs. Vision",
                                                          "grad3" = "Gradient 3: Default mode vs. frontoparietal")
  )) +
  scale_fill_distiller(name = "F value", palette = "RdBu", limits = c(-7,7), values = c(0, 0.25, 0.5, 0.75, 1)) +
  ggtitle("Gradients: Controls > SSD\n(significant results; FDR-corrected)")+
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank()) + 
  theme_brain(text.family = "Calibri")

glasser_brain
```

```{r, echo = FALSE, fig.show = 'hold', out.width = '50%'}
## results from F-test filtered by p_FDR
all_roi_test <- all_roi_results %>%
  filter(term == "diagnostic_groupcontrol") %>%
  mutate(roi = str_remove(ROI, "_ROI"),
         label = case_when(str_starts(ROI, "L") ~ str_c("lh_", roi),
                           str_starts(ROI, "R_") ~ str_c("rh_", roi)),
         statistic.cor = ifelse(p_FDR < 0.05, statistic, 0)) %>%
  filter(ROI != "L_10pp_ROI") %>%
  as.data.frame() %>%
  group_by(gradient)

## Plot gradients
## Gradients 1 & 2
G1G2.roi.control <- createFactorMap(spins_mean_bygrp[,6:8],
                        axis1 = 1, axis2 = 2,
                        col.points = roi.col$oc[spins_mean_bygrp$ROI,],
                        alpha.points = 0.1, 
                        col.background = "grey96",
                        col.axes = "grey30")

G1G2.mean.control <- createFactorMap(net_mean_bygrp[,5:7],
                                     axis1 = 1, axis2 = 2,
                                     col.points = roi.col$gc[net_mean_bygrp$Network,],
                                     col.labels = roi.col$gc[net_mean_bygrp$Network,],
                                     cex = 2,
                                     text.cex = 3,
                                     alpha.points = 0.7,
                                     col.background = "grey96",
                                     col.axes = "grey30")

G1G2.roi.control$zeMap_background + G1G2.roi.control$zeMap_dots + G1G2.mean.control$zeMap_dots + G1G2.mean.control$zeMap_text + xlab( "Gradient 1") + ylab("Gradient 2") + ggtitle("Gradients: Healthy controls")

G1G2.roi.case <- createFactorMap(spins_mean_bygrp[,3:5],
                        axis1 = 1, axis2 = 2,
                        col.points = roi.col$oc[spins_mean_bygrp$ROI,],
                        alpha.points = 0.1, 
                        col.background = "grey96",
                        col.axes = "grey30")

G1G2.mean.case <- createFactorMap(net_mean_bygrp[,2:4],
                                  axis1 = 1, axis2 = 2,
                                  col.points = roi.col$gc[net_mean_bygrp$Network,],
                                  col.labels = roi.col$gc[net_mean_bygrp$Network,],
                                  cex = 2,
                                  text.cex = 3,
                                  alpha.points = 0.7,
                                  col.background = "grey96",
                                  col.axes = "grey30")

G1G2.roi.case$zeMap_background + G1G2.roi.case$zeMap_dots + G1G2.mean.case$zeMap_dots + G1G2.mean.case$zeMap_text + xlab( "Gradient 1") + ylab("Gradient 2") + ggtitle("Gradients: SSD")

## Gradients 2 & 3
G2G3.roi.control <- createFactorMap(spins_mean_bygrp[,6:8],
                        axis1 = 2, axis2 = 3,
                        col.points = roi.col$oc[spins_mean_bygrp$ROI,],
                        alpha.points = 0.1, 
                        col.background = "grey96",
                        col.axes = "grey30")

G2G3.mean.control <- createFactorMap(net_mean_bygrp[,5:7],
                                     axis1 = 2, axis2 = 3,
                                     col.points = roi.col$gc[net_mean_bygrp$Network,],
                                     col.labels = roi.col$gc[net_mean_bygrp$Network,],
                                     cex = 2,
                                     text.cex = 3,
                                     alpha.points = 0.7,
                                     col.background = "grey96",
                                     col.axes = "grey30")

G2G3.roi.control$zeMap_background + G2G3.roi.control$zeMap_dots + G2G3.mean.control$zeMap_dots + G2G3.mean.control$zeMap_text + xlab( "Gradient 2") + ylab("Gradient 3") + ggtitle("Gradients: Healthy controls")

G2G3.roi.case <- createFactorMap(spins_mean_bygrp[,3:5],
                        axis1 = 2, axis2 = 3,
                        col.points = roi.col$oc[spins_mean_bygrp$ROI,],
                        alpha.points = 0.1, 
                        col.background = "grey96",
                        col.axes = "grey30")

G2G3.mean.case <- createFactorMap(net_mean_bygrp[,2:4],
                                  axis1 = 2, axis2 = 3,
                                  col.points = roi.col$gc[net_mean_bygrp$Network,],
                                  col.labels = roi.col$gc[net_mean_bygrp$Network,],
                                  cex = 2,
                                  text.cex = 3,
                                  alpha.points = 0.7,
                                  col.background = "grey96",
                                  col.axes = "grey30")

G2G3.roi.case$zeMap_background + G2G3.roi.case$zeMap_dots + G2G3.mean.case$zeMap_dots + G2G3.mean.case$zeMap_text + xlab( "Gradient 2") + ylab("Gradient 3") + ggtitle("Gradients: SSD")


```


<!-- 3D plot of the gradients -->

<!-- ```{r, echo = FALSE} -->
<!-- data4plotly <- data.frame(spins_mean, grad4grp[rownames(spins_mean),]) -->
<!-- data4plotly.case <- data.frame(spins_mean_bygrp[,3:5], grad4grp2[spins_mean_bygrp$ROI,]) -->
<!-- data4plotly.control <- data.frame(spins_mean_bygrp[,6:8], grad4grp2[spins_mean_bygrp$ROI,]) -->
<!-- color4plotly <- net.col.idx -->

<!-- ## overall average -->
<!-- fig <- plot_ly(data4plotly, x = ~grad1, y = ~grad2, z = ~grad3, color = ~Network, colors = color4plotly, alpha = 0.5, size = 5)   -->
<!-- fig <- fig %>% add_markers() -->
<!-- fig <- fig %>% layout(title = "Overall: mean gradients by ROIs", -->
<!--                       scene = list(xaxis = list(title = "Gradient 1"), -->
<!--                                    yaxis = list(title = "Gradient 2"), -->
<!--                                    zaxis = list(title = "Gradient 3"))) -->
<!-- ## case -->
<!-- fig.case <- plot_ly(data4plotly.case, x = ~grad1.case, y = ~grad2.case, z = ~grad3.case, color = ~Network, colors = color4plotly, alpha = 0.5, size = 5)   -->
<!-- fig.case <- fig.case %>% add_markers() -->
<!-- fig.case <- fig.case %>% layout(title = "Case: mean gradients by ROIs", -->
<!--                                 scene = list(xaxis = list(title = "Gradient 1"), -->
<!--                                              yaxis = list(title = "Gradient 2"), -->
<!--                                              zaxis = list(title = "Gradient 3"))) -->

<!-- ## control -->
<!-- fig.control <- plot_ly(data4plotly.control, x = ~grad1.control, y = ~grad2.control, z = ~grad3.control, color = ~Network, colors = color4plotly, alpha = 0.5, size = 5)   -->
<!-- fig.control <- fig.control %>% add_markers() -->
<!-- fig.control <- fig.control %>% layout(title = "Control: mean gradients by ROIs", -->
<!--                                       scene = list(xaxis = list(title = "Gradient 1"), -->
<!--                                                    yaxis = list(title = "Gradient 2"), -->
<!--                                                    zaxis = list(title = "Gradient 3"))) -->

<!-- ## print 3 -->
<!-- fig -->
<!-- fig.case -->
<!-- fig.control -->

<!-- ``` -->


```{r, echo = FALSE, warning= FALSE, message='hide'}
### Gradients 1 & 2
G1G2 <- createFactorMap(grad2plot,
                        axis1 = 1, axis2 = 2,
                        col.points = roi.col$oc[rownames(grad2plot),],
                        alpha.points = 0.1, 
                        col.background = "grey96",
                        col.axes = "grey30")

G1G2.mean <- createFactorMap(net_mean,
                             axis1 = 1, axis2 = 2,
                             col.points = roi.col$gc[rownames(net_mean),],
                             col.labels = roi.col$gc[rownames(net_mean),],
                             cex = 4,
                             text.cex = 3,
                             alpha.points = 0.7,
                        col.background = "grey96",
                        col.axes = "grey30")


G1G2.arrows.dim1 <- annotate("segment", x = net_mean$`Gradient 1`, y = net_mean$`Gradient 2`, xend = net_mean$`Gradient 1` + net_mean.fj$Dim1.grad1, yend = net_mean$`Gradient 2` + net_mean.fj$Dim1.grad2,
                             color = arrow.col, alpha = 0.8, arrow = arrow(length = unit(0.25, "cm"), type = "closed", angle = 20), size = 1)
G1G2.arrows.dim2 <- annotate("segment", x = net_mean$`Gradient 1`, y = net_mean$`Gradient 2`, xend = net_mean$`Gradient 1` + net_mean.fj$Dim2.grad1, yend = net_mean$`Gradient 2` + net_mean.fj$Dim2.grad2,
                             color = arrow.col, alpha = 0.8, arrow = arrow(length = unit(0.25, "cm"), type = "closed", angle = 20), size = 1)
G1G2.arrows.dim3 <- annotate("segment", x = net_mean$`Gradient 1`, y = net_mean$`Gradient 2`, xend = net_mean$`Gradient 1` + net_mean.fj$Dim3.grad1, yend = net_mean$`Gradient 2` + net_mean.fj$Dim3.grad2,
                             color = arrow.col, alpha = 0.8, arrow = arrow(length = unit(0.25, "cm"), type = "closed", angle = 20), size = 1)

G1G2.arrows <- annotate("segment", x = net_mean_bygrp$grad1.control, y = net_mean_bygrp$grad2.control, xend = net_mean_bygrp$grad1.case, yend = net_mean_bygrp$grad2.case, 
                        color = arrow.col, alpha = 1, arrow = arrow(length = unit(0.2, "cm"), type = "closed", angle = 30), size = 0.5)
```

```{r, echo = FALSE, warning= FALSE, message='hide'}
### Gradients 2 & 3
G2G3 <- createFactorMap(grad2plot,
                        axis1 = 2, axis2 = 3,
                        col.points = roi.col$oc[rownames(grad2plot),],
                        alpha.points = 0.1,
                        col.background = "grey96",
                        col.axes = "grey30")

G2G3.mean <- createFactorMap(net_mean,
                             axis1 = 2, axis2 = 3,
                             col.points = roi.col$gc[rownames(net_mean),],
                             col.labels = roi.col$gc[rownames(net_mean),],
                             cex = 4,
                             text.cex = 3,
                             alpha.points = 0.7,
                        col.background = "grey96",
                        col.axes = "grey30"
                             )

G2G3.arrows.dim1 <- annotate("segment", x = net_mean$`Gradient 2`, y = net_mean$`Gradient 3`, xend = net_mean$`Gradient 2` + net_mean.fj$Dim1.grad2, yend = net_mean$`Gradient 3` + net_mean.fj$Dim1.grad3, 
                             color = arrow.col, alpha = 0.8, arrow = arrow(length = unit(0.25, "cm"), type = "closed", angle = 20), size = 1)
G2G3.arrows.dim2 <- annotate("segment", x = net_mean$`Gradient 2`, y = net_mean$`Gradient 3`, xend = net_mean$`Gradient 2` + net_mean.fj$Dim2.grad2, yend = net_mean$`Gradient 3` + net_mean.fj$Dim2.grad3, 
                             color = arrow.col, alpha = 0.8, arrow = arrow(length = unit(0.25, "cm"), type = "closed", angle = 20), size = 1)
G2G3.arrows.dim3 <- annotate("segment", x = net_mean$`Gradient 2`, y = net_mean$`Gradient 3`, xend = net_mean$`Gradient 2` + net_mean.fj$Dim3.grad2, yend = net_mean$`Gradient 3` + net_mean.fj$Dim3.grad3, 
                             color = arrow.col, alpha = 0.8, arrow = arrow(length = unit(0.25, "cm"), type = "closed", angle = 20), size = 1)

G2G3.arrows <- annotate("segment", x = net_mean_bygrp$grad2.control, y = net_mean_bygrp$grad3.control, xend = net_mean_bygrp$grad2.case, yend = net_mean_bygrp$grad3.case, 
                        color = "black", alpha = 1, arrow = arrow(length = unit(0.2, "cm"), type = "closed", angle = 30), size = 0.5)

G2G3.arrows.roi <- annotate("segment", x = grad2plot2$grad2.control, y = grad2plot2$grad3.control, xend = grad2plot2$grad2.case, yend = grad2plot2$grad3.case, color = roi.col$oc[rownames(grad2plot2),], alpha = 0.2, arrow = arrow(length = unit(0.2, "cm"), type = "closed", angle = 20), linewidth = 0.8)
```

```{r, echo = FALSE, warning= FALSE, message='hide'}
### Gradients 1 & 3
G1G3 <- createFactorMap(grad2plot,
                        axis1 = 1, axis2 = 3,
                        col.points = roi.col$oc[rownames(grad2plot),],
                        alpha.points = 0.1, 
                        col.background = "grey96",
                        col.axes = "grey30")

G1G3.mean <- createFactorMap(net_mean,
                             axis1 = 1, axis2 = 3,
                             col.points = roi.col$gc[rownames(net_mean),],
                             col.labels = roi.col$gc[rownames(net_mean),],
                             cex = 4,
                             text.cex = 3,
                             alpha.points = 0.7,
                        col.background = "grey96",
                        col.axes = "grey30")

G1G3.mean.control <- createFactorMap(net_mean_bygrp[,5:7],
                                     axis1 = 1, axis2 = 3,
                                     col.points = roi.col$gc[net_mean_bygrp$Network,],
                                     col.labels = roi.col$gc[net_mean_bygrp$Network,],
                                     cex = 2,
                                     text.cex = 3,
                                     alpha.points = 0.7,
                                     col.background = "grey96",
                                     col.axes = "grey30")

G1G3.mean.case <- createFactorMap(net_mean_bygrp[,2:4],
                                  axis1 = 1, axis2 = 3,
                                  col.points = roi.col$gc[net_mean_bygrp$Network,],
                                  col.labels = roi.col$gc[net_mean_bygrp$Network,],
                                  cex = 2,
                                  text.cex = 3,
                                  alpha.points = 0.7,
                                  col.background = "grey96",
                                  col.axes = "grey30")

G1G3.arrows.dim1 <- annotate("segment", x = net_mean$`Gradient 1`, y = net_mean$`Gradient 3`, xend = net_mean$`Gradient 1` + net_mean.fj$Dim1.grad1, yend = net_mean$`Gradient 3` + net_mean.fj$Dim1.grad3, 
                             color = arrow.col, alpha = 0.8, arrow = arrow(length = unit(0.25, "cm"), type = "closed", angle = 20), size = 1)
G1G3.arrows.dim2 <- annotate("segment", x = net_mean$`Gradient 1`, y = net_mean$`Gradient 3`, xend = net_mean$`Gradient 1` + net_mean.fj$Dim2.grad1, yend = net_mean$`Gradient 3` + net_mean.fj$Dim2.grad3, 
                             color = arrow.col, alpha = 0.8, arrow = arrow(length = unit(0.25, "cm"), type = "closed", angle = 20), size = 1)
G1G3.arrows.dim3 <- annotate("segment", x = net_mean$`Gradient 1`, y = net_mean$`Gradient 3`, xend = net_mean$`Gradient 1` + net_mean.fj$Dim3.grad1, yend = net_mean$`Gradient 3` + net_mean.fj$Dim3.grad3, 
                             color = arrow.col, alpha = 0.8, arrow = arrow(length = unit(0.25, "cm"), type = "closed", angle = 20), size = 1)
G1G3.arrows <- annotate("segment", x = net_mean_bygrp$grad1.control, y = net_mean_bygrp$grad3.control, xend = net_mean_bygrp$grad1.case, yend = net_mean_bygrp$grad3.case, 
                        color = "black", alpha = 1, arrow = arrow(length = unit(0.2, "cm"), type = "closed", angle = 30), size = 0.5)
```

### Group difference

```{r, echo = FALSE, warning= FALSE, message='hide', fig.show='hold', out.width='50%'}
G1G2.mean.control$zeMap + G1G2.arrows + xlab( "Gradient 1") + ylab("Gradient 2") + ggtitle("From control to case")
G2G3.mean.control$zeMap + G2G3.arrows + xlab( "Gradient 2") + ylab("Gradient 3") + ggtitle("From control to case")
# G1G3.mean.control$zeMap + G1G3.arrows + ggtitle("From control to case")
# G1G2.mean.control$zeMap_background + G1G2.mean.case$zeMap_text + G1G2.arrows + ggtitle("From control to case")
# 
# G2G3.mean.control$zeMap_background + G2G3.mean.case$zeMap_text + G2G3.arrows + ggtitle("From control to case")
# G2G3.mean.control$zeMap + ggtitle("Control")
# G2G3.mean.case$zeMap + ggtitle("Case")
# 
# G1G3.mean.control$zeMap_background + G1G3.mean.case$zeMap_text + G1G3.arrows + ggtitle("From control to case")
# G1G3.mean.control$zeMap + ggtitle("Control")
# G1G3.mean.case$zeMap + ggtitle("Case")

```

### visualization

#### Group effect

```{r, echo = FALSE, warning= FALSE, message='hide', fig.show='hold', out.width='50%'}

G1G2.arrows.roi <- annotate("segment", 
                            x = grad2plot2$grad1.control, 
                            y = grad2plot2$grad2.control, 
                            xend = grad2plot2$grad1.case, 
                            yend = grad2plot2$grad2.case, 
                            color = roi.col$oc[rownames(grad2plot2),], 
                            alpha = 0.2, 
                            arrow = arrow(length = unit(0.2, "cm"), 
                                          type = "closed", angle = 20), 
                            linewidth = 0.8)

G1G2.mean.control$zeMap_background + G1G2.mean.control$zeMap_text + G1G2.arrows.roi + xlab( "Gradient 1") + ylab("Gradient 2") + ggtitle("From control to case")

G2G3.arrows.roi <- annotate("segment", 
                            x = grad2plot2$grad2.control, 
                            y = grad2plot2$grad3.control, 
                            xend = grad2plot2$grad2.case, 
                            yend = grad2plot2$grad3.case, 
                            color = roi.col$oc[rownames(grad2plot2),], 
                            alpha = 0.2, 
                            arrow = arrow(length = unit(0.2, "cm"), 
                                          type = "closed", angle = 20), 
                            linewidth = 0.8)

G2G3.mean.control$zeMap_background + G2G3.mean.control$zeMap_text + G2G3.arrows.roi + xlab( "Gradient 2") + ylab("Gradient 3") + ggtitle("From control to case")
```

#### By contributions and significance to PLS


```{r, echo = FALSE, warning= FALSE, message='hide', fig.show='hold', out.width='50%'}
G1G2.arrows.roi.impG1 <- annotate("segment", 
                            x = grad2plot2$grad1.control, 
                            y = grad2plot2$grad2.control, 
                            xend = grad2plot2$grad1.case, 
                            yend = grad2plot2$grad2.case, 
                            color = roi.col$oc[rownames(grad2plot2),], 
                            alpha = spins_cj$grad1[rownames(grad2plot2), "cjimp1"]*100,#0.2, 
                            arrow = arrow(length = unit(0.2, "cm"), 
                                          type = "closed", angle = 20), 
                            linewidth = 0.8)
G1G2.arrows.roi.sigG1pos <- annotate("segment", 
                            x = grad2plot2$grad1.control, 
                            y = grad2plot2$grad2.control, 
                            xend = grad2plot2$grad1.case, 
                            yend = grad2plot2$grad2.case, 
                            color = roi.col$oc[rownames(grad2plot2),], 
                            alpha = spins_cj$grad1[rownames(grad2plot2), "cjsig1.pos"]*100,#0.2, 
                            arrow = arrow(length = unit(0.2, "cm"), 
                                          type = "closed", angle = 20), 
                            linewidth = 0.8)
G1G2.arrows.roi.sigG1neg <- annotate("segment", 
                            x = grad2plot2$grad1.control, 
                            y = grad2plot2$grad2.control, 
                            xend = grad2plot2$grad1.case, 
                            yend = grad2plot2$grad2.case, 
                            color = roi.col$oc[rownames(grad2plot2),], 
                            alpha = spins_cj$grad1[rownames(grad2plot2), "cjsig1.neg"]*100,#0.2, 
                            arrow = arrow(length = unit(0.2, "cm"), 
                                          type = "closed", angle = 20), 
                            linewidth = 0.8)

G1G2.mean.control$zeMap_background + G1G2.mean.control$zeMap_text + G1G2.arrows.roi.impG1 + xlab( "Gradient 1") + ylab("Gradient 2") + ggtitle("From control to case\nContribute more than average")
glasser_brain4plot
G1G2.mean.control$zeMap_background + G1G2.mean.control$zeMap_text + G1G2.arrows.roi.sigG1pos + xlab( "Gradient 1") + ylab("Gradient 2") + ggtitle("From control to case\nSignificant contribution: positive")
G1G2.mean.control$zeMap_background + G1G2.mean.control$zeMap_text + G1G2.arrows.roi.sigG1neg + xlab( "Gradient 1") + ylab("Gradient 2") + ggtitle("From control to case\nSignificant contribution: negative")

G2G3.arrows.roi.impG2 <- annotate("segment", 
                            x = grad2plot2$grad2.control, 
                            y = grad2plot2$grad3.control, 
                            xend = grad2plot2$grad2.case, 
                            yend = grad2plot2$grad3.case, 
                            color = roi.col$oc[rownames(grad2plot2),], 
                            alpha = spins_cj$grad2[rownames(grad2plot2), "cjimp1"]*100,#0.2, 
                            arrow = arrow(length = unit(0.2, "cm"), 
                                          type = "closed", angle = 20), 
                            linewidth = 0.8)

G2G3.arrows.roi.sigG2pos <- annotate("segment", 
                            x = grad2plot2$grad2.control, 
                            y = grad2plot2$grad3.control, 
                            xend = grad2plot2$grad2.case, 
                            yend = grad2plot2$grad3.case, 
                            color = roi.col$oc[rownames(grad2plot2),], 
                            alpha = spins_cj$grad2[rownames(grad2plot2), "cjsig1.pos"]*100,#0.2, 
                            arrow = arrow(length = unit(0.2, "cm"), 
                                          type = "closed", angle = 20), 
                            linewidth = 0.8)

G2G3.arrows.roi.sigG2neg <- annotate("segment", 
                            x = grad2plot2$grad2.control, 
                            y = grad2plot2$grad3.control, 
                            xend = grad2plot2$grad2.case, 
                            yend = grad2plot2$grad3.case, 
                            color = roi.col$oc[rownames(grad2plot2),], 
                            alpha = spins_cj$grad2[rownames(grad2plot2), "cjsig1.neg"]*100,#0.2, 
                            arrow = arrow(length = unit(0.2, "cm"), 
                                          type = "closed", angle = 20), 
                            linewidth = 0.8)

G2G3.mean.control$zeMap_background + G2G3.mean.control$zeMap_text + G2G3.arrows.roi.impG2 + xlab( "Gradient 2") + ylab("Gradient 3") + ggtitle("From control to case\nContribute more than average")

glasser_brain4plot

G2G3.mean.control$zeMap_background + G2G3.mean.control$zeMap_text + G2G3.arrows.roi.sigG2pos + xlab( "Gradient 2") + ylab("Gradient 3") + ggtitle("From control to case\nSignificant contribution: positive")
G2G3.mean.control$zeMap_background + G2G3.mean.control$zeMap_text + G2G3.arrows.roi.sigG2neg + xlab( "Gradient 2") + ylab("Gradient 3") + ggtitle("From control to case\nSignificant contribution: negative")

G2G3.arrows.roi.impG3 <- annotate("segment", 
                            x = grad2plot2$grad2.control, 
                            y = grad2plot2$grad3.control, 
                            xend = grad2plot2$grad2.case, 
                            yend = grad2plot2$grad3.case, 
                            color = roi.col$oc[rownames(grad2plot2),], 
                            alpha = spins_cj$grad3[rownames(grad2plot2), "cjimp1"]*100,#0.2, 
                            arrow = arrow(length = unit(0.2, "cm"), 
                                          type = "closed", angle = 20), 
                            linewidth = 0.8)

G2G3.arrows.roi.sigG3pos <- annotate("segment", 
                            x = grad2plot2$grad2.control, 
                            y = grad2plot2$grad3.control, 
                            xend = grad2plot2$grad2.case, 
                            yend = grad2plot2$grad3.case, 
                            color = roi.col$oc[rownames(grad2plot2),], 
                            alpha = spins_cj$grad3[rownames(grad2plot2), "cjsig1.pos"]*100,#0.2, 
                            arrow = arrow(length = unit(0.2, "cm"), 
                                          type = "closed", angle = 20), 
                            linewidth = 0.8)

G2G3.arrows.roi.sigG3neg <- annotate("segment", 
                            x = grad2plot2$grad2.control, 
                            y = grad2plot2$grad3.control, 
                            xend = grad2plot2$grad2.case, 
                            yend = grad2plot2$grad3.case, 
                            color = roi.col$oc[rownames(grad2plot2),], 
                            alpha = spins_cj$grad3[rownames(grad2plot2), "cjsig1.neg"]*100,#0.2, 
                            arrow = arrow(length = unit(0.2, "cm"), 
                                          type = "closed", angle = 20), 
                            linewidth = 0.8)
G2G3.mean.control$zeMap_background + G2G3.mean.control$zeMap_text + G2G3.arrows.roi.impG3 + xlab( "Gradient 2") + ylab("Gradient 3") + ggtitle("From control to case")
glasser_brain4plot

G2G3.mean.control$zeMap_background + G2G3.mean.control$zeMap_text + G2G3.arrows.roi.sigG3pos + xlab( "Gradient 2") + ylab("Gradient 3") + ggtitle("From control to case")
G2G3.mean.control$zeMap_background + G2G3.mean.control$zeMap_text + G2G3.arrows.roi.sigG3neg + xlab( "Gradient 2") + ylab("Gradient 3") + ggtitle("From control to case")

```

### Subcortical

```{r, echo = FALSE, warning= FALSE, message='hide', include = FALSE}
subcor.col <- c("grey60", "grey60", "#a6cee3", "#1f78b4", "white", "#b2df8a", "white", "#B03060", "#ff7f00", "#CD6889", "white", "white", "#33a02c", "#EE9A49", "#B452CD", "#68228B", "#FFD700", "#D1AE22", rep("white", 11)) %>% setNames(aseg$data$label)
names(subcor.col)[c(1,2,29)] <- NA

asegbrain <- ggseg(atlas="aseg", 
        mapping=aes(fill= label), 
        colour="black", 
        size=.5,
        hemisphere = c("left", "right")) + 
  scale_fill_manual(name = "Regions", values = subcor.col) +
  theme(axis.text.y.left = element_blank(), 
        axis.text.x.bottom = element_blank(),
        legend.position = "right",
        legend.spacing = unit(0.2, "cm"), 
        legend.key.height = unit(0.2, "cm"), legend.key.width = unit(0.4, "cm") ) + 
  theme_brain(text.family = "Calibri") +
   guides(name = "Regions", fill = guide_legend(nrow = 8))
  
asegbrain

asegbrainInPlot <- asegbrain + theme(legend.position = "", text = element_blank())
```

```{r, echo = FALSE, warning= FALSE, message='hide', include = FALSE}
# grab data

## by group (original gradients)
subroi2plot2 <- grad2plot2[grad4grp2$Network == "Subcortical",]
## by gradients (cj)
spins_cj_subcor <- spins_cj
lapply(spins_cj_subcor, function(x){
  subcort.dat <- x[ROI.idx == "Subcortical",]
  return(subcort.dat)
})

# grab color
subroi.col <- c(rep("#33a02c", 2), # right hippocampus
rep("#ff7f00", 2), # right amygdala
rep("#1f78b4", 4), # right thalamas
rep("#b15928", 2), # right NAcc
rep("#68228B", 2), # right GP
rep("#B03060", 2), # right putaman
rep("#D1AE22", 2), # right caudate
rep("#b2df8a", 2), # left hippocampus
rep("#EE9A49", 2), # left amygdata
rep("#a6cee3", 4), # left thalamas
rep("#B57957", 2), # left Nacc
rep("#B452CD", 2), # left GP
rep("#CD6889", 2), # left putaman
rep("#FFD700", 2)) # left caudate


roi.subcor.idx <- ROI.idx[ROI.idx == "Subcortical"] %>% as.data.frame
colnames(roi.subcor.idx) <- "Network"
roi.subcor.idx$color <- subroi.col
```

#### Group effect

```{r, echo = FALSE, warning= FALSE, message='hide', fig.show='hold', out.width='50%'}
## group labels
G1G2.mean.control4subcort <- createFactorMap(net_mean_bygrp[,5:7],
                                     axis1 = 1, axis2 = 2,
                                     col.points = roi.col$gc[net_mean_bygrp$Network,],
                                     col.labels = roi.col$gc[net_mean_bygrp$Network,],
                                     cex = 2,
                                     text.cex = 3,
                                     alpha.points = 0.7,
                                     alpha.labels = ifelse(net_mean_bygrp$Network == "Subcortical", 1, 0.5),
                                     col.background = "grey96",
                                     col.axes = "grey30")

G2G3.mean.control4subcort <- createFactorMap(net_mean_bygrp[,5:7],
                                     axis1 = 2, axis2 = 3,
                                     col.points = roi.col$gc[net_mean_bygrp$Network,],
                                     col.labels = roi.col$gc[net_mean_bygrp$Network,],
                                     cex = 2,
                                     text.cex = 3,
                                     alpha.points = 0.7,
                                     alpha.labels = ifelse(net_mean_bygrp$Network == "Subcortical", 1, 0.5),
                                     col.background = "grey96",
                                     col.axes = "grey30")

## the arrows
G1G2.arrows.subcorROI <- annotate("segment", 
                            x = subroi2plot2$grad1.control, 
                            y = subroi2plot2$grad2.control, 
                            xend = subroi2plot2$grad1.case, 
                            yend = subroi2plot2$grad2.case, 
                            color = roi.subcor.idx[rownames(subroi2plot2), "color"], 
                            alpha = 0.8, 
                            arrow = arrow(length = unit(0.2, "cm"), 
                                          type = "closed", angle = 30), 
                            linewidth = 0.8)

G1G2.mean.control4subcort$zeMap_background + G1G2.mean.control4subcort$zeMap_text + G1G2.arrows.subcorROI + xlab( "Gradient 1") + ylab("Gradient 2") + ggtitle("From control to case") + annotation_custom(ggplotify::as.grob(asegbrainInPlot),0,1.1,0.55,1.75)

G2G3.arrows.subcorROI <- annotate("segment", 
                            x = subroi2plot2$grad2.control, 
                            y = subroi2plot2$grad3.control, 
                            xend = subroi2plot2$grad2.case, 
                            yend = subroi2plot2$grad3.case, 
                            color = roi.subcor.idx[rownames(subroi2plot2), "color"], 
                            alpha = 0.8, 
                            arrow = arrow(length = unit(0.2, "cm"), 
                                          type = "closed", angle = 30), 
                            linewidth = 0.8)

G2G3.mean.control4subcort$zeMap_background + G2G3.mean.control4subcort$zeMap_text + G2G3.arrows.subcorROI + xlab( "Gradient 2") + ylab("Gradient 3") + ggtitle("From control to case") + annotation_custom(ggplotify::as.grob(asegbrainInPlot),0.75,1.75,-0.15,0.75)

```

#### By contributions and significance to PLS


```{r, echo = FALSE, warning= FALSE, message='hide', fig.show='hold', out.width='50%'}
G1G2.arrows.subcorROI.impG1 <- annotate("segment", 
                            x = subroi2plot2$grad1.control, 
                            y = subroi2plot2$grad2.control, 
                            xend = subroi2plot2$grad1.case, 
                            yend = subroi2plot2$grad2.case, 
                            color = roi.subcor.idx[rownames(subroi2plot2),"color"], 
                            alpha = spins_cj_subcor$grad1[rownames(subroi2plot2), "cjimp1"]*100,#0.2, 
                            arrow = arrow(length = unit(0.2, "cm"), 
                                          type = "closed", angle = 30), 
                            linewidth = 0.8)
G1G2.arrows.subcorROI.sigG1pos <- annotate("segment", 
                            x = subroi2plot2$grad1.control, 
                            y = subroi2plot2$grad2.control, 
                            xend = subroi2plot2$grad1.case, 
                            yend = subroi2plot2$grad2.case, 
                            color = roi.subcor.idx[rownames(subroi2plot2),"color"], 
                            alpha = spins_cj_subcor$grad1[rownames(subroi2plot2), "cjsig1.pos"]*100,#0.2, 
                            arrow = arrow(length = unit(0.2, "cm"), 
                                          type = "closed", angle = 30), 
                            linewidth = 0.8)
G1G2.arrows.subcorROI.sigG1neg <- annotate("segment", 
                            x = subroi2plot2$grad1.control, 
                            y = subroi2plot2$grad2.control, 
                            xend = subroi2plot2$grad1.case, 
                            yend = subroi2plot2$grad2.case, 
                            color = roi.subcor.idx[rownames(subroi2plot2),"color"], 
                            alpha = spins_cj_subcor$grad1[rownames(subroi2plot2), "cjsig1.neg"]*100,#0.2, 
                            arrow = arrow(length = unit(0.2, "cm"), 
                                          type = "closed", angle = 30), 
                            linewidth = 0.8)

G1G2.mean.control4subcort$zeMap_background + G1G2.mean.control4subcort$zeMap_text + G1G2.arrows.subcorROI.impG1 + xlab( "Gradient 1") + ylab("Gradient 2") + ggtitle("From control to case\nContribute more than average") + annotation_custom(ggplotify::as.grob(asegbrainInPlot),0,1.1,0.55,1.75)
ggplot()
G1G2.mean.control4subcort$zeMap_background + G1G2.mean.control4subcort$zeMap_text + G1G2.arrows.subcorROI.sigG1pos + xlab( "Gradient 1") + ylab("Gradient 2") + ggtitle("From control to case\nSignificant contribution: positive") + annotation_custom(ggplotify::as.grob(asegbrainInPlot),0,1.1,0.55,1.75)
G1G2.mean.control4subcort$zeMap_background + G1G2.mean.control4subcort$zeMap_text + G1G2.arrows.subcorROI.sigG1neg + xlab( "Gradient 1") + ylab("Gradient 2") + ggtitle("From control to case\nSignificant contribution: negative") + annotation_custom(ggplotify::as.grob(asegbrainInPlot),0,1.1,0.55,1.75)

G2G3.arrows.subcorROI.impG2 <- annotate("segment", 
                            x = subroi2plot2$grad2.control, 
                            y = subroi2plot2$grad3.control, 
                            xend = subroi2plot2$grad2.case, 
                            yend = subroi2plot2$grad3.case, 
                            color = roi.subcor.idx[rownames(subroi2plot2),"color"], 
                            alpha = spins_cj_subcor$grad2[rownames(subroi2plot2), "cjimp1"]*100,#0.2, 
                            arrow = arrow(length = unit(0.2, "cm"), 
                                          type = "closed", angle = 30), 
                            linewidth = 0.8)

G2G3.arrows.subcorROI.sigG2pos <- annotate("segment", 
                            x = subroi2plot2$grad2.control, 
                            y = subroi2plot2$grad3.control, 
                            xend = subroi2plot2$grad2.case, 
                            yend = subroi2plot2$grad3.case, 
                            color = roi.subcor.idx[rownames(subroi2plot2),"color"], 
                            alpha = spins_cj_subcor$grad2[rownames(subroi2plot2), "cjsig1.pos"]*100,#0.2, 
                            arrow = arrow(length = unit(0.2, "cm"), 
                                          type = "closed", angle = 30), 
                            linewidth = 0.8)

G2G3.arrows.subcorROI.sigG2neg <- annotate("segment", 
                            x = subroi2plot2$grad2.control, 
                            y = subroi2plot2$grad3.control, 
                            xend = subroi2plot2$grad2.case, 
                            yend = subroi2plot2$grad3.case, 
                            color = roi.subcor.idx[rownames(subroi2plot2),"color"], 
                            alpha = spins_cj_subcor$grad2[rownames(subroi2plot2), "cjsig1.neg"]*100,#0.2, 
                            arrow = arrow(length = unit(0.2, "cm"), 
                                          type = "closed", angle = 30), 
                            linewidth = 0.8)

G2G3.mean.control4subcort$zeMap_background + G2G3.mean.control4subcort$zeMap_text + G2G3.arrows.subcorROI.impG2 + xlab( "Gradient 2") + ylab("Gradient 3") + ggtitle("From control to case\nContribute more than average") + annotation_custom(ggplotify::as.grob(asegbrainInPlot),0.75,1.75,-0.15,0.75)
ggplot()
G2G3.mean.control4subcort$zeMap_background + G2G3.mean.control4subcort$zeMap_text + G2G3.arrows.subcorROI.sigG2pos + xlab( "Gradient 2") + ylab("Gradient 3") + ggtitle("From control to case\nSignificant contribution: positive") + annotation_custom(ggplotify::as.grob(asegbrainInPlot),0.75,1.75,-0.15,0.75)
G2G3.mean.control4subcort$zeMap_background + G2G3.mean.control4subcort$zeMap_text + G2G3.arrows.subcorROI.sigG2neg + xlab( "Gradient 2") + ylab("Gradient 3") + ggtitle("From control to case\nSignificant contribution: negative") + annotation_custom(ggplotify::as.grob(asegbrainInPlot),0.75,1.75,-0.15,0.75)

G2G3.arrows.subcorROI.impG3 <- annotate("segment", 
                            x = subroi2plot2$grad2.control, 
                            y = subroi2plot2$grad3.control, 
                            xend = subroi2plot2$grad2.case, 
                            yend = subroi2plot2$grad3.case, 
                            color = roi.subcor.idx[rownames(subroi2plot2),"color"], 
                            alpha = spins_cj_subcor$grad3[rownames(subroi2plot2), "cjimp1"]*100,#0.2, 
                            arrow = arrow(length = unit(0.2, "cm"), 
                                          type = "closed", angle = 30), 
                            linewidth = 0.8)

G2G3.arrows.subcorROI.sigG3pos <- annotate("segment", 
                            x = subroi2plot2$grad2.control, 
                            y = subroi2plot2$grad3.control, 
                            xend = subroi2plot2$grad2.case, 
                            yend = subroi2plot2$grad3.case, 
                            color = roi.subcor.idx[rownames(subroi2plot2),"color"], 
                            alpha = spins_cj_subcor$grad3[rownames(subroi2plot2), "cjsig1.pos"]*100,#0.2, 
                            arrow = arrow(length = unit(0.2, "cm"), 
                                          type = "closed", angle = 30), 
                            linewidth = 0.8)

G2G3.arrows.subcorROI.sigG3neg <- annotate("segment", 
                            x = subroi2plot2$grad2.control, 
                            y = subroi2plot2$grad3.control, 
                            xend = subroi2plot2$grad2.case, 
                            yend = subroi2plot2$grad3.case, 
                            color = roi.subcor.idx[rownames(subroi2plot2),"color"], 
                            alpha = spins_cj_subcor$grad3[rownames(subroi2plot2), "cjsig1.neg"]*100,#0.2, 
                            arrow = arrow(length = unit(0.2, "cm"), 
                                          type = "closed", angle = 30), 
                            linewidth = 0.8)
G2G3.mean.control4subcort$zeMap_background + G2G3.mean.control4subcort$zeMap_text + G2G3.arrows.subcorROI.impG3 + xlab( "Gradient 2") + ylab("Gradient 3") + ggtitle("From control to case") + annotation_custom(ggplotify::as.grob(asegbrainInPlot),0.75,1.75,-0.15,0.75)
ggplot()
G2G3.mean.control4subcort$zeMap_background + G2G3.mean.control4subcort$zeMap_text + G2G3.arrows.subcorROI.sigG3pos + xlab( "Gradient 2") + ylab("Gradient 3") + ggtitle("From control to case") + annotation_custom(ggplotify::as.grob(asegbrainInPlot),0.75,1.75,-0.15,0.75)
G2G3.mean.control4subcort$zeMap_background + G2G3.mean.control4subcort$zeMap_text + G2G3.arrows.subcorROI.sigG3neg + xlab( "Gradient 2") + ylab("Gradient 3") + ggtitle("From control to case") + annotation_custom(ggplotify::as.grob(asegbrainInPlot),0.75,1.75,-0.15,0.75)

```

<!-- ### Dimension 1 -->

<!-- We need to interpret the arrows with cautious, because only the direction and the magnitude are meaningful but not the end point. -->

<!-- ```{r, echo = FALSE, fig.show='hold', out.width='50%'} -->
<!-- G1G2$zeMap_background + G1G2$zeMap_dots + G1G2.mean$zeMap_text + G1G2.mean$zeMap_dots + G1G2.arrows.dim1 -->
<!-- G2G3$zeMap_background + G2G3$zeMap_dots + G2G3.mean$zeMap_text + G2G3.mean$zeMap_dots + G2G3.arrows.dim1 -->
<!-- G1G3$zeMap_background + G1G3$zeMap_dots + G1G3.mean$zeMap_text + G1G3.mean$zeMap_dots + G1G3.arrows.dim1 -->
<!-- ``` -->

<!-- ### Dimension 2 -->

<!-- We need to interpret the arrows with cautious, because only the direction and the magnitude are meaningful but not the end point. -->

<!-- ```{r, echo = FALSE, fig.show='hold', out.width='50%'} -->
<!-- G1G2$zeMap_background + G1G2$zeMap_dots + G1G2.mean$zeMap_text + G1G2.mean$zeMap_dots + G1G2.arrows.dim2 -->
<!-- G2G3$zeMap_background + G2G3$zeMap_dots + G2G3.mean$zeMap_text + G2G3.mean$zeMap_dots + G2G3.arrows.dim2 -->
<!-- G1G3$zeMap_background + G1G3$zeMap_dots + G1G3.mean$zeMap_text + G1G3.mean$zeMap_dots + G1G3.arrows.dim2 -->
<!-- ``` -->

<!-- ### Dimension 3 -->

<!-- We need to interpret the arrows with cautious, because only the direction and the magnitude are meaningful but not the end point. -->

<!-- ```{r, echo = FALSE, fig.show='hold', out.width='50%'} -->
<!-- G1G2$zeMap_background + G1G2$zeMap_dots + G1G2.mean$zeMap_text + G1G2.mean$zeMap_dots + G1G2.arrows.dim3 -->
<!-- G2G3$zeMap_background + G2G3$zeMap_dots + G2G3.mean$zeMap_text + G2G3.mean$zeMap_dots + G2G3.arrows.dim3 -->
<!-- G1G3$zeMap_background + G1G3$zeMap_dots + G1G3.mean$zeMap_text + G1G3.mean$zeMap_dots + G1G3.arrows.dim3 -->
<!-- ``` -->

## Relationship to symptoms {.tabset}

### Correlation to composite scores

```{r, echo = FALSE}
behav_sympt <- read.csv("../data/spins_behav_data_full_03-03-2022.csv") %>%
  select(record_id, bsfs_total, qls_total, bprs_factor_total, sans_total_sc, 
         bsfs_sec1_total, bsfs_sec2_total, bsfs_sec3_total, bsfs_sec4_total, bsfs_sec5_total, bsfs_sec6_total,
    qls20_empathy, qls_factor_interpersonal, qls_factor_instrumental_role,
    qls_factor_intrapsychic, qls_factor_comm_obj_activities, bprs_factor_neg_symp,
    bprs_factor_pos_symp, bprs_factor_anxiety_depression, bprs_factor_activation, bprs_factor_hostility, sans_sub_affective_flat_blunt, sans_sub_alogia, sans_sub_avolition_apathy, sans_sub_asocial_anhedonia)
rownames(behav_sympt) <- behav_sympt$record_id

lol_spins_behav_smp <- cbind(lol_spins_behav, behav_sympt[lol_spins_behav$record_id, ])
lol_spins_behav_ssd <- lol_spins_behav_smp[lol_spins_behav_smp$diagnostic_group == "case",]
lol_spins_behav_ssd <- lol_spins_behav_ssd[complete.cases(lol_spins_behav_ssd),] # removing two people with missing qls

## SSD subjects
ssd.sub <- lol_spins_behav_ssd$record_id

## design matrix for subjects
spins_dx_ssd <- lol_spins_behav_ssd %>%
  select(subject,scanner,diagnostic_group,demo_sex,demo_age_study_entry)

## numeric data
spins_symp_ssd <- lol_spins_behav_ssd %>% 
  select(
    bsfs_total, qls_total, bprs_factor_total, sans_total_sc
  ) %>% data.frame
rownames(spins_symp_ssd) <- lol_spins_behav_ssd$record_id

## select lx/ly
ssd.lx <- pls.res$TExPosition.Data$lx[ssd.sub,]
ssd.ly <- pls.res$TExPosition.Data$ly[ssd.sub,]

## color for symptoms measures

## design matrix for columns - behavioral 
sympt.dx <- matrix(nrow = ncol(spins_symp_ssd), ncol = 1, dimnames = list(colnames(spins_symp_ssd), "type")) %>% as.data.frame

sympt.col <- c("bsfs" = "#D37295",
               "bprs" = "#E15759",
               "qls" = "#B07AA1",
               "qls20" = "#B07AA1",
               "sans" = "#FF9888")

sympt.dx$type <- sub("(^[^_]+).*", "\\1", colnames(spins_symp_ssd))
sympt.dx$type.col <- recode(sympt.dx$type, !!!sympt.col)

```

```{r, echo = FALSE, warning= FALSE, message='hide'}
corrplot::corrplot(cor(cbind(spins_symp_ssd, ssd.lx[,1:2], ssd.ly[,1:2])), method = "shade")

colnames(spins_symp_ssd) <- c("Birchwood Social Functioning Scale ", "Quality of Life Scale", "Brief Psychiatric Rating Scale", "SANS Negative Symptoms")
lxly.12 <- cbind(ssd.lx[,1], ssd.ly[,1],ssd.lx[,2], ssd.ly[,2])
colnames(lxly.12) <- c("Behavioural scores.Dim1", "Brain scores.Dim1", "Behavioural scores.Dim2", "Brain scores.Dim2")

cor.mat <- psych::corr.test(spins_symp_ssd, lxly.12, adjust = "fdr")

## plot
corrplot::corrplot(t(cor.mat$r), method = "shade", addCoef.col = TRUE, addCoefasPercent = TRUE, number.font = 0.2, p.mat = t(cor.mat$p), insig = "blank", title = "Correlation with FDR correction")

panel.lm<-
function (x, y, col = par("col"), bg = NA, pch = par("pch"),
cex = 1, col.lm = "red", lwd=par("lwd"), ...)
{
points(x, y, pch = pch, col = col, bg = bg, cex = cex)
ok <- is.finite(x) & is.finite(y)
if (any(ok))
    abline(lm(y~x,subset=ok), col = col.lm, lwd = lwd, ...)
}

TeachingDemos::pairs2(spins_symp_ssd, lxly.12, panel=panel.lm, pch = 16, col.lm = "darkorchid3", lwd = 3)
```

### Correlation to individual scores

```{r, echo = FALSE}
## numeric data
spins_symp_ssd_indiv <- lol_spins_behav_ssd %>% 
  select(
    bsfs_sec1_total, bsfs_sec2_total, bsfs_sec3_total, bsfs_sec4_total, bsfs_sec5_total, bsfs_sec6_total,
qls_factor_interpersonal, qls_factor_instrumental_role,
    qls_factor_intrapsychic, qls_factor_comm_obj_activities, bprs_factor_neg_symp,
    bprs_factor_pos_symp, bprs_factor_anxiety_depression, bprs_factor_activation, bprs_factor_hostility, sans_sub_affective_flat_blunt, sans_sub_alogia, sans_sub_avolition_apathy, sans_sub_asocial_anhedonia
  ) %>% data.frame
rownames(spins_symp_ssd_indiv) <- lol_spins_behav_ssd$record_id

```

```{r, echo = FALSE, warning= FALSE, message='hide'}
corrplot::corrplot(cor(cbind(spins_symp_ssd_indiv, ssd.lx[,1:2], ssd.ly[,1:2])), method = "shade")

cor.indiv.mat <- psych::corr.test(spins_symp_ssd_indiv, lxly.12, adjust = "fdr")

rownames(cor.indiv.mat$r) <- c("bsfs1: Social engagement/withdrawn", "bsfs2: Interpersonal communication/relationship", "bsfs3: Interpersonal prosocial activity", "bsfs4: Recreation activity", "bsfs5: Independence-performance", "bsfs6: Independence-competence", "qls: Interpersonal", "qls: Instrumental role", "qls: Intrapsychic foundations", "qls: Common objects and activities", "bprs: Negative symptoms", "bprs: Positive symptoms", "bprs: Anxiety/depression", "bprs: Activation", "bprs: hostility", "sans: Affective flattening or blunting", "sans: Alogia", "sans: Avolition/Apathy", "sans: Asociality/Anhedonia")

## plot
corrplot::corrplot(t(cor.indiv.mat$r), method = "shade", addCoef.col = TRUE, addCoefasPercent = TRUE, number.font = 0.2, p.mat = t(cor.indiv.mat$p), insig = "pch", title = "Correlation with FDR correction")

panel.lm<-
function (x, y, col = par("col"), bg = NA, pch = par("pch"),
cex = 1, col.lm = "red", lwd=par("lwd"), ...)
{
points(x, y, pch = pch, col = col, bg = bg, cex = cex)
ok <- is.finite(x) & is.finite(y)
if (any(ok))
    abline(lm(y~x,subset=ok), col = col.lm, lwd = lwd, ...)
}

TeachingDemos::pairs2(spins_symp_ssd_indiv, lxly.12, panel=panel.lm, pch = 16, col.lm = "darkorchid3", lwd = 3)

# ## do PCA
# pca.symp <- epPCA(lxly.12, graphs = FALSE)
# 
# PlotScree(pca.symp$ExPosition.Data$eigs)
# 
# fj.map <- createFactorMap(pca.symp$ExPosition.Data$fj,
#                           # col.points = sympt.dx$type.col,
#                           # col.labels = sympt.dx$type.col
#                           )
# fj.arrows <- addArrows(pca.symp$ExPosition.Data$fj,
#                        # color = sympt.dx$type.col
#                        )
# 
# fj.map$zeMap + fj.arrows
# 
# cor.lxly <- cor(cbind(lxly.12, spins_symp_ssd), pca.symp$ExPosition.Data$fi)
# circor <- createFactorMap(cor.lxly,
#                           col.labels = c(rep("darkorchid4", 4), sympt.dx$type.col))
# arrow.cor <- addArrows(cor.lxly,
#                        color = c(rep("darkorchid4", 4), sympt.dx$type.col))
# circor$zeMap_background + circor$zeMap_text + arrow.cor + addCircleOfCor()

```

```{r, include = FALSE}
save(pls.res, pls.boot, pq_for_plot, grad.dat, sub.dx, file = "../data/pls_grad_combat_res.rda")
```